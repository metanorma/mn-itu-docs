= Specification and Description Language – Overview of SDL-2010
:bureau: T
:docnumber: Z.100
:series: Z: Languages and General Software Aspects for Telecommunication Systems
:series1: Formal description techniques (FDT)
:series2: Specification and Description Language (SDL)
:published-date: 2018-11-01
:copyright-year: 2018
:status: in-force
:doctype: recommendation-annex
:annexid: F1
:annextitle: SDL-2010 formal definition: General overview
:keywords: abstract state machines, ASM, formal definition, overview, overview of semantics, SDL-2010, specification and description language
:imagesdir: images
:docfile: Z.100-201811-AnnF1.adoc
:mn-document-class: itu
:mn-output-extensions: xml,html,doc,pdf,rxl
:local-cache-only:
:data-uri-image:
:section-refsig: Clause
:annexid: F1
:annextitle: SDL-2010 formal definition: General overview
:xrefstyle: short



[abstract]
== Summary
Annex F1 provides the motivation for and the main objectives of a formal semantics definition for SDL-2010. It gives an overview of the structure of the formal semantics, and it also contains an introduction to the Abstract State Machine (ASM) formalism, which is used to define the SDL-2010 semantics.

[preface]
== History
[%unnumbered,cols="2,2,1,^2,^2"]
|===
^.^| Edition ^.^| Recommendation ^.^| Approval ^.^| Study Group ^.^|
Unique ID{blank}footnote:[To access the Recommendation, type the URL http://handle.itu.int/ in the address field of your web browser, followed by the Recommendation's unique ID. For example, http://handle.itu.int/11.1002/1000/11830-en[].]

^.^| [[ihistorye]]1.0 <.<| ITU-T Z.100 ^.^| 1984-10-19 ^.^| <.<| http://handle.itu.int/11.1002/1000/2222[11.1002/1000/2222]
^.^| 1.1 <.<| ITU-T Z.100 Annex A ^.^| 1984-10-19 ^.^| <.<| http://handle.itu.int/11.1002/1000/6664[11.1002/1000/6664]
^.^| 1.2 <.<| ITU-T Z.100 Annex B ^.^| 1984-10-19 ^.^| <.<| http://handle.itu.int/11.1002/1000/6665[11.1002/1000/6665]
^.^| 1.3 <.<| ITU-T Z.100 Annex C1 ^.^| 1984-10-19 ^.^| <.<| http://handle.itu.int/11.1002/1000/6666[11.1002/1000/6666]
^.^| 1.4 <.<| ITU-T Z.100 Annex C2 ^.^| 1984-10-19 ^.^| <.<| http://handle.itu.int/11.1002/1000/6667[11.1002/1000/6667]
^.^| 1.5 <.<| ITU-T Z.100 Annex D ^.^| 1984-10-19 ^.^| <.<| http://handle.itu.int/11.1002/1000/6668[11.1002/1000/6668]
^.^| 2.0 <.<| ITU-T Z.100 ^.^| 1987-09-30 ^.^| X <.<| http://handle.itu.int/11.1002/1000/10954[11.1002/1000/10954]
^.^| 2.1 <.<| ITU-T Z.100 Annex A ^.^| 1988-11-25 ^.^| <.<| http://handle.itu.int/11.1002/1000/6669[11.1002/1000/6669]
^.^| 2.2 <.<| ITU-T Z.100 Annex B ^.^| 1988-11-25 ^.^| <.<| http://handle.itu.int/11.1002/1000/6670[11.1002/1000/6670]
^.^| 2.3 <.<| ITU-T Z.100 Annex C1 ^.^| 1988-11-25 ^.^| <.<| http://handle.itu.int/11.1002/1000/6671[11.1002/1000/6671]
^.^| 2.4 <.<| ITU-T Z.100 Annex C2 ^.^| 1988-11-25 ^.^| <.<| http://handle.itu.int/11.1002/1000/6672[11.1002/1000/6672]
^.^| 2.5 <.<| ITU-T Z.100 Annex D ^.^| 1988-11-25 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3646[11.1002/1000/3646]
^.^| 2.6 <.<| ITU-T Z.100 Annex E ^.^| 1988-11-25 ^.^| <.<| http://handle.itu.int/11.1002/1000/6673[11.1002/1000/6673]
^.^| 2.7 <.<| ITU-T Z.100 Annex F1 ^.^| 1988-11-25 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3647[11.1002/1000/3647]
^.^| 2.8 <.<| ITU-T Z.100 Annex F2 ^.^| 1988-11-25 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3648[11.1002/1000/3648]
^.^| 2.9 <.<| ITU-T Z.100 Annex F3 ^.^| 1988-11-25 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3649[11.1002/1000/3649]
^.^| 3.0 <.<| ITU-T Z.100 ^.^| 1988-11-25 ^.^| <.<| http://handle.itu.int/11.1002/1000/3153[11.1002/1000/3153]
^.^| 3.1 <.<| ITU-T Z.100 Annex C ^.^| 1993-03-12 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3155[11.1002/1000/3155]
^.^| 3.2 <.<| ITU-T Z.100 Annex D ^.^| 1993-03-12 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3156[11.1002/1000/3156]
^.^| 3.3 <.<| ITU-T Z.100 Annex F1 ^.^| 1993-03-12 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3157[11.1002/1000/3157]
^.^| 3.4 <.<| ITU-T Z.100 Annex F2 ^.^| 1993-03-12 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3158[11.1002/1000/3158]
^.^| 3.5 <.<| ITU-T Z.100 Annex F3 ^.^| 1993-03-12 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3159[11.1002/1000/3159]
^.^| 3.6 <.<| ITU-T Z.100 App. I ^.^| 1993-03-12 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3160[11.1002/1000/3160]
^.^| 3.7 <.<| ITU-T Z.100 App. II ^.^| 1993-03-12 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3161[11.1002/1000/3161]
^.^| 4.0 <.<| ITU-T Z.100 ^.^| 1993-03-12 ^.^| X <.<| http://handle.itu.int/11.1002/1000/3154[11.1002/1000/3154]
^.^| 4.1 <.<| ITU-T Z.100 (1993) Add. 1 ^.^| 1996-10-18 ^.^| 10 <.<| http://handle.itu.int/11.1002/1000/3917[11.1002/1000/3917]
^.^| 5.0 <.<| ITU-T Z.100 ^.^| 1999-11-19 ^.^| 10 <.<| http://handle.itu.int/11.1002/1000/4764[11.1002/1000/4764]
^.^| 5.1 <.<| ITU-T Z.100 (1999) Cor. 1 ^.^| 2001-10-29 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/5567[11.1002/1000/5567]
^.^| 6.0 <.<| ITU-T Z.100 ^.^| 2002-08-06 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/6029[11.1002/1000/6029]
^.^| 6.1 <.<| ITU-T Z.100 (2002) Amd. 1 ^.^| 2003-10-29 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/7091[11.1002/1000/7091]
^.^| 6.2 <.<| ITU-T Z.100 (2002) Cor. 1 ^.^| 2004-08-29 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/356[11.1002/1000/356]
^.^| 7.0 <.<| ITU-T Z.100 ^.^| 2007-11-13 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/9262[11.1002/1000/9262]
^.^| 8.0 <.<| ITU-T Z.100 ^.^| 2011-12-22 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/11387[11.1002/1000/11387]
^.^| 8.1 <.<| ITU-T Z.100 Annex F1 ^.^| 2000-11-24 ^.^| 10 <.<| http://handle.itu.int/11.1002/1000/5239[11.1002/1000/5239]
^.^| 8.2 <.<| ITU-T Z.100 Annex F2 ^.^| 2000-11-24 ^.^| 10 <.<| http://handle.itu.int/11.1002/1000/5576[11.1002/1000/5576]
^.^| 8.3 <.<| ITU-T Z.100 Annex F3 ^.^| 2000-11-24 ^.^| 10 <.<| http://handle.itu.int/11.1002/1000/5577[11.1002/1000/5577]
^.^| 8.4 <.<| ITU-T Z.100 Annex F1 ^.^| 2015-01-13 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/12354[11.1002/1000/12354]
^.^| 8.5 <.<| ITU-T Z.100 Annex F2 ^.^| 2015-01-13 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/12355[11.1002/1000/12355]
^.^| 8.6 <.<| ITU-T Z.100 Annex F3 ^.^| 2015-01-13 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/12356[11.1002/1000/12356]
^.^| 9.0 <.<| ITU-T Z.100 ^.^| 2016-04-29 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/12846[11.1002/1000/12846]
^.^| 9.1 <.<| ITU-T Z.100 Annex F1 ^.^| 2016-10-29 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/13040[11.1002/1000/13040]
^.^| 9.2 <.<| ITU-T Z.100 Annex F2 ^.^| 2016-10-29 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/13041[11.1002/1000/13041]
^.^| 9.3 <.<| ITU-T Z.100 Annex F3 ^.^| 2016-10-29 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/13042[11.1002/1000/13042]
^.^| 9.4 <.<| ITU-T Z.100 Annex F1 ^.^| 2018-11-13 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/13732[11.1002/1000/13732]
^.^| 9.5 <.<| ITU-T Z.100 Annex F2 ^.^| 2018-11-13 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/13733[11.1002/1000/13733]
^.^| 9.6 <.<| ITU-T Z.100 Annex F3 ^.^| 2018-11-13 ^.^| 17 <.<| http://handle.itu.int/11.1002/1000/13734[11.1002/1000/13734]
|===


[appendix]
== SDL 2010 formal definition: General overview

[[status_of_annex_f1]]
=== Preface

The formal definition of SDL-2010 provided in this annex is a precise language definition, which supplements the definition given in the Recommendation text. It is for use by those requiring a very precise definition of SDL-2010, such as maintainers of the SDL-2010 language, designers of SDL-2010 tools and users of the SDL-2010 language.

The formal definition consists of three annexes:

*Annex F1*:: This annex provides the motivation for and the main objectives of a formal semantics definition for SDL-2010. It gives an overview of the structure of the formal semantics, and contains an introduction to the Abstract State Machine (ASM) formalism, which is used to define the SDL-2010 semantics.

*Annex F2*:: This annex describes the static semantic constraints of SDL-2010, as well as the transformations identified by the 'Model' sections of the ITU-T Z.100 series for SDL-2010.

*Annex F3*:: This annex defines the dynamic semantics of SDL-2010.


[[motivation]]
==== Motivation

SDL-2010 has both a formal syntax and a formal semantics. Annexes F1, F2 and F3 define the formal semantics of SDL-2010. If there is any inconsistency between Annexes F1, F2 and F3 and other parts of the ITU-T Z.100 series for SDL-2010, then there is an error that needs correcting. Neither the other parts of the ITU-T Z.100 series for SDL-2010 nor Annexes F1, F2 and F3 take precedence in this case.

[[main_objectives]]
==== Main objectives

A primary objective of a formal SDL-2010 semantics is intelligibility, a prerequisite for correctness, acceptance and maintainability. Intelligibility is supported by building on well-known mathematical formalisms and notations, by a close correspondence between the specification technique and semantics to be formalized, and by concise and well-structured documentation.

Maintainability is another important objective because SDL-2010 is an evolving technical standard. Apart from the language extensions that are incorporated into this Recommendation, further language features under consideration. Therefore, the mathematical formalism has to be sufficiently rich and flexible so that the formal semantics can be adapted and extended with a reasonable effort.

SDL-2010 can be classified as a model-oriented formal description technique (FDT) for the specification of distributed and concurrent systems, which means that an SDL-2010 specification explicitly defines a set of computations. This calls for an operational semantics in order to achieve a close correspondence with the specification, and thus improve its intelligibility. In addition, operational semantics lends itself naturally to executability (<<b-Eschbach>>, <<b-Eschbach_2001>> and <<b-Glaesser>>), which, given the availability of tools, fulfils another explicit objective.

[[references_and_definitions]]
==== References and definitions

The references and definitions of the main body of Recommendation ITU-T Z.100 apply throughout Annexes F1, F2 and F3.

[bibliography]
==== Bibliographical references (for this annex only)

* [[[b-ASM,b-ASM]]], http://www.eecs.umich.edu/gasm/[] (accessed 20 March 2018)

* [[[b-Blass,b-Blass]]], Blass, A. and Gurevich, Y. (2003), _Abstract State Machines capture parallel algorithms_, ACM Transactions on Computational Logic, Vol. 4, No. 4, ACM. +
NOTE: The axiomatic definition of abstract state machines for sequential algorithms is modified to capture parallel algorithms. Specifically, Bounded Exploration is replaced by Background, Proclet (sub-process of a parallel algorithm that contains no unbounded parallelism) and Bounded Sequentiality to ensure that the number of state elements involved in a given computation step is bounded, with the bound depending only on the algorithm and not on the state.

* [[[b-Blass_2008,b-Blass 2008]]], Blass, A. and Gurevich, Y. (2008), _Abstract State machines capture parallel algorithms: Correction and extension_. ACM Transactions on Computational Logic, Vol. 9, No. 3, ACM. +
NOTE: The postulates presented in <<b-Blass>> do not allow proclets to be created on the fly. On the fly creation of proclets is required to correct one of the flaws identified in the examples in Section 8 of <<b-Blass>>. Other flaws in the earlier article have also been corrected.

* [[[b-Boerger,b-Börger]]], Börger, E. (2003), _The ASM Refinement Method_, Formal Aspects of Computing Vol. 15, pp. 237-257, BCS.

* [[[b-BoergerStaerk,b-Börger & Stärk]]], Börger, E., and Stärk, R. S. (2003), _Abstract State Machines: A Method for High-Level System Design and Analysis_, Springer-Verlag. +
NOTE: Design and analysis for multi-agent as well as single agent abstract state machines. Used here to clarify the coherence condition.

* [[[b-Eschbach,b-Eschbach]]], Eschbach, R., Glässer, U., Gotzhein, R., and Prinz, A. (2000), _On the Formal Semantics of SDL-2000: A Compilation Approach Based on an Abstract SDL Machine_, in: Y. Gurevich, M. Odersky, P. Kutter, L. Thiele (Eds.), Abstract State Machines – Theory and Applications, Lecture Notes in Computer Science, Vol. 1912, Springer-Verlag.

* [[[b-Eschbach_2001,b-Eschbach 2001]]], Eschbach, R., Glässer, U., Gotzhein, R., von Löwis, M., and Prinz, A. (2001), _Formal Definition of SDL-2000: Compiling and Running SDL Specifications as ASM Models_, Journal of Universal Computer Science Vol. 7, No. 11, pp. 1024-1049, Springer.

* [[[b-Glaesser,b-Glässer]]], Glässer, U., Gotzhein, R., Prinz, A. (2003), _The formal semantics of SDL-2000 – Status and perspectives_, Computer Networks, Vol. 42, No. 3, pp. 343-358, Elsevier Sciences. +
NOTE: The design objectives of the SDL semantics include executability, intelligibility, conciseness and flexibility as well as the ideals of correctness and completeness (for which indisputable evidence cannot be inferred from the SDL grammars and textual description). The decision to base the SDL formal semantics on ASM is documented, and the ITU-Tapproach is described. This approach entails analysis of an SDL model and synthesis of an ASM program that defines the behaviour of SDL agents. Execution is defined in terms of the SDL virtual machine, which provides operating system functionality that controls the execution of ASM programs on the logical hardware of the SDL abstract machine (SAM).

* [[[b-Glaesser_2007,b-Glässer 2007]]], Glässer, U., Gurevich, Y., and Veanes, M. (2007), _Abstract Communication Model for Distributed Systems_, IEEE Transactions on Software Engineering, Vol. 30, No. 7, pp. 458-472. +
NOTE: A high level abstract model for message based communication networks is presented. The model is based on distributed abstract state machines, has been implemented in AsmL and has been used for testing distributed systems.

* [[[b-Glausch,b-Glausch]]], Glausch, A. and Reisig, W. (2007), _A Semantic Characterization of Unbounded-Nondeterministic Abstract State Machines_, in T Mossakowski et al. (Eds.) CALCO 2007, LNCS 4624, Springer-Verlag. +
NOTE: The axiomatic definition given by Gurevich for the sequential algorithms captured by ASMs is extended to nondeterministic ASMs. Unbounded nondeterminism means that there may be uncountably many update sets that could be produced by an algorithm in a given state. However, so long as each of these is bounded in size, the fact that only one of them is applied means that the number of state elements involved in a computation step is bounded.

* [[[b-Gurevich,b-Gurevich]]] Gurevich, Y. (1995), _Evolving algebras 1993: Lipari guide,_ in Specification and validation methods, Börger, E. (ed.), pp. 9-36, Oxford University Press.

* [[[b-Gurevich_2000,b-Gurevich 2000]]], Gurevich, Y. (2000), _Sequential Abstract State Machines Capture Sequential Algorithms_, Microsoft Research.

[[status_of_annex_f1_this_annex]]
==== Status of Annex F1 (this annex)

The (01/2015) edition was an improvement on the previous edition, because it updated the description of ASM and the list of references. The (10/2016) edition clarified a number of items in the (01/2015) edition and added descriptions of items used in F2 and/or F3 that were previously missing or newly added to F2 and/or F3. This edition is essentially a maintenance update further clarifying existing content and adding additional features used in F2 and/or F3.

[[overview_of_the_semantics]]
=== Overview of the semantics

In order to define the formal semantics of SDL-2010, the language definition is decomposed into several parts:

* grammar

* well-formedness conditions

* transformation rules

* dynamic semantics.

The starting point for defining the formal semantics of SDL-2010 is a syntactically correct SDL-2010 specification, represented as an abstract syntax tree (AST).

The first three parts of the formal semantics are collectively referred to as _static semantics_ or _static aspects_ in the context of SDL-2010 (see <<fig-f1-1>>), and are described in Part 2 of the formal definition, i.e., Annex F2.

[[fig-f1-1]]
.Static aspects of SDL-2010
image::Z.100-201811-AnnF1/image3.png[]

The _grammar_ defines the set of syntactically correct SDL-2010 specifications. The ITU-T Z.100 series for SDL-2010 defines a concrete graphical grammar, a concrete textual grammar, and an abstract grammar. The syntax of the concrete grammars is defined formally using the Backus-Naur form (BNF) with some extensions to capture the graphical language constructs (see clause 5.4.1 of [ITU-T Z.111]). The abstract grammar is obtained from the concrete grammars by removing irrelevant details such as separators and lexical rules, and by applying transformation rules (see below). The syntax of the abstract grammar is defined in the textual presentation metalanguage for abstract grammar (see clause 5.4.1.1 of [ITU-T Z.111]).

From the specifications that are correct with respect to the grammar syntax, the _well-formedness conditions_ define the specifications that are also correct with respect to context information. The well-formedness conditions address matters of scope, visibility and type. The well-formedness conditions are defined in terms of first order predicate calculus (PC1).

Furthermore, some language constructs appearing in the concrete grammars are replaced by other language elements in the abstract grammar using _transformation rules_ to keep the set of core concepts small. These transformations are described in the 'Model' paragraphs of the ITU-T Z.100 series for SDL-2010, and are formally expressed as rewrite rules.

The _dynamic semantics_ applies only to syntactically correct SDL-2010 specifications that satisfy the well-formedness conditions. The dynamic semantics defines the set of computations associated with a specification, and are described in Part 3 of the formal definition, i.e., Annex F3.

[[grammar]]
==== Grammar

The _grammar_ of SDL-2010 is formalized as described above. The primary concrete grammar is given for SDL-GR. Most of the grammar of SDL-GR is textual, but it has some graphical elements. To enable formalisation of SDL-2010 specifications into ASM, any SDL-GR graphical element is changed to the equivalent concrete textual representation (SDL-PR) defined in [ITU-T Z.106]. The grammar in the ITU-T Z.100 series for SDL-2010 is designed to be a presentation grammar: it is not adapted to automatic parser generation. Moreover, some restrictions that finally guarantee uniqueness of the semantics cannot be expressed in BNF and have been stated in the text instead. Therefore, the grammar is defined using BNF and some text (mostly for the precedence rules). The translation from the concrete textual SDL-2010 representation to the abstract syntax representation of SDL-2010 (called AS1) consists of two steps. The first step from the concrete textual SDL-2010 representation to AS0 (the concrete syntax with details such as separators and lexical rules removed) is not formally defined, but is derived from the correspondence between the two grammars, which is almost one-to-one. The second step, translating AS0 to AS1, is formally captured by a set of transformation rules (see Annex F2).

[[well_formedness_conditions]]
==== Well-formedness conditions

The _well-formedness conditions_ define additional constraints that a well-formed SDL-2010 specification has to satisfy. These constraints cannot be expressed using context-free grammar rules, but they are static, and can be defined and checked independently of the dynamic semantics of SDL-2010 (see Annex F2). An SDL-2010 specification is _valid_ if and only if it satisfies the syntactical rules and the static conditions of SDL-2010. The well-formedness conditions are context-dependent conditions on elements of a context free grammar.

There are five kinds of well-formedness conditions:

* _Scope/visibility rules_: The definition of an entity introduces an identifier used as the reference to the entity. Only the use of visible identifiers is allowed. The scope/visibility rules are applied to determine whether the corresponding definition of an identifier is visible or not.

* _Disambiguation rules_: Sometimes a name might refer to several identifiers. Rules are applied to find out the correct one.

* _Data type consistency rules_: These rules ensure that dynamically, no operation is applied to operands that do not match its argument types. More specifically, the data type of an actual parameter has to be compatible with that of the corresponding formal parameter; and the data type of an expression has to be compatible with that of the variable to which the expression is assigned.

* _Special rules_: There are some rules applicable to specific entities. For example, it is not allowed to export a procedure variable (that is, a variable defined within a procedure).

* _Plain syntax rules_: There are some rules that refer to the correctness of the concrete syntax, and that have no counterpart in the abstract syntax. For instance, the names at the beginning and at the end of a definition in SDL-PR have to match.

[[transformation_rules]]
==== Transformation rules

For a language with a rich syntax, it is important to identify the core concepts matching the intentions of the language designer. Further language constructs, such as shorthand notations, that are introduced for convenience, but do not add to the expressiveness of the language, can be replaced using these core concepts. Since replacements, which are described by transformation rules, can be formalized, it suffices to define the dynamic semantics only for the core concepts, which adds to its conciseness and intelligibility. <<fig-f1-1>> illustrates the general approach. The language is defined with its concrete grammar using lexical and syntax rules. Consistency constraints are defined on this concrete grammar.

The ITU-T Z.100 series for SDL-2010 prescribes the transformation of SDL-2010 specifications by a sequence of _transformation steps_. Each transformation step consists of a set of single transformations as stated in the _Model_ clauses, and determines how to handle one special class of shorthand notations. The result of one step is used as input for the next step.

To formalize the transformation rules of SDL-2010, the rewrite rules in PC1 are used. These rules define patterns of the AST, which are to be replaced by other AST patterns. In fact, several groups of such rewrite rules are defined that are applied in turn. A single transformation is realized by the application of a rewrite rule to the concrete specification, which essentially means to replace parts of the specification by other parts as defined by the rule (see Annex F2).

[[dynamic_semantics]]
==== Dynamic semantics

The _dynamic semantics_ (clauses F3.2 and F3.3) consists of the following parts (see <<fig-f1-2>>):

. The _SDL-2010 Abstract Machine (SAM)_: this is defined using ASM. The definition of the SAM is divided into three parts, corresponding to the abstract syntax:

.. basic signal flow concepts (such as signals, timers, gates, channels) defined in terms of an ASM model in clause F3.2.1.1;

.. various types of ASM agents to model corresponding SDL-2010 agents in clause F3.2.1.2; and

.. signal processing and behaviour primitives (the abstract machine instructions of the SAM) in clause F3.2.1.4 (that uses the interface to the data type part in clause F3.2.1.3).

. The _compilation function_ (clause F3.2.2): this maps the AST of an SDL-2010 specification to _SAM_ behaviour primitives that model the actions of the SDL-2010 agents. The compilation function amounts to an abstract compiler taking the AST of the state machines as input and transforming it to _SAM_ instructions.

. The _SAM Programs_ (clause F3.2.3): these define the set of computations. These programs consist of an initialization phase and an execution phase. SAM programs have fixed parts that are the same for all SDL-2010 specifications, and variable parts that are generated from the abstract syntax representation of a given SDL-2010 specification.

.. The _initialization_ (clause F3.2.3.1) phase handles static structural properties of the specification. The pre-initial state of a system is defined followed by several initialization programs. The initial system state is then reached by creating the SDL-2010 system agent, and by activating this agent in the pre-initial state. The initialization recursively unfolds the static structure of the system, creating further SDL-2010 agents as specified so that all the initial objects are created. The same process is initiated in the subsequent execution phase, whenever SDL-2010 agents are created. From this point of view, the initialization merely describes the instantiation of the SDL-2010 system agent.

.. The _execution_ (clause F3.2.3.2) phase is modelled by distinguishing two alternating phases, namely the selection and the firing of transitions.

. The _data semantics_ (clause F3.3): this is separated from the rest of the semantics by an interface (clause F3.2.1.3). The use of an interface is intentional at this place. It allows the data model to be exchanged, if for some application area another data model is more appropriate than the SDL-2010 built-in model. Moreover, the SDL-2010 built-in model can be changed this way without affecting the rest of the semantics.

[[fig-f1-2]]
.Overview of the dynamic semantics
image::Z.100-201811-AnnF1/image4.png[]


The formal semantics is formalized starting from the abstract syntax AS1 of SDL-2010. From this abstract syntax, a behaviour model for SDL-2010 specifications is derived that can be understood as abstract code generated from an SDL-2010 specification. The approach chosen here is based on an abstract operational view using the ASM formalism as the underlying mathematical framework for a rigorous semantic definition of the SAM model. The compilation defines an abstract compiler mapping the behaviour parts of SDL-2010 to abstract code (denotational semantics). Finally, the initialization describes an interpretation of the abstract syntax tree to build the initial system structure (operational semantics).

The _dynamic semantics_ associates a particular distributed, real-time ASM with each SDL-2010 specification. Intuitively, an ASM consists of a set of autonomous agents cooperatively performing concurrent machine runs. The behaviour of an agent is determined by an ASM program, each consisting of a transition rule that defines the set of possible computations (called "runs" in the context of ASM). Each agent has its own partial view on a global state, which is defined by a set of static and dynamic functions and domains. By having non-empty intersections of partial views, interaction among agents can be modelled. An introduction to the ASM model, and the notation used in Annexes F1, F2 and F3, is given in <<abstract_state_machines>>.

[[abstract_state_machines]]
=== Abstract State Machines

This clause explains the basic notions and concepts of _Abstract State Machines_ (_ASM_) as well as the notation used in these Annexes F1, F2 and F3 to define the SDL-2010 abstract machine model. The objective here is to provide an intuitive understanding of the formalism; for a rigorous definition of the mathematical foundations of ASM and its application, the reader is referred to <<b-Gurevich>>, <<b-Blass>>, <<b-Blass_2008>>, <<b-Glausch>>, <<b-BoergerStaerk>> and <<b-Boerger>>. A discussion and motivation of the appropriateness of the semantic framework used here is given in <<b-Eschbach>>, <<b-Eschbach_2001>> and <<b-Glaesser>>. Further references on ASM-related material can also be found on the ASM webpages <<b-ASM>>.

The ASM model used to define the dynamic semantics of SDL-2010 is explained in several steps. Firstly, the _basic ASM model_ with a single agent is treated (see <<basic_asm_model>>). Next, this model is extended to cover _multi-agent systems_ (see <<distributed_multi_agent_asm>>). Then, _open systems_, i.e., systems interacting with an environment they cannot control, are addressed by adding the notion of _external world_ (see <<the_external_world>>). Finally, the model is extended by introducing a notion of _real-time behaviour_ (see <<real_time_behaviour>>). To illustrate these steps, an ASM model for a simple system is developed, step-by-step. The final ASM model of this system is summarized in <<example_the_system_rms>>. Additional notation used to define the dynamic semantics of SDL-2010 is explained in <<predefined_names_and_special_symbols>>.


.A simple resource management system (_RMS_):
====

In order to illustrate the ASM model, a simple resource management system (_RMS_) consisting of _a group of_ stem:[n > 1] _agents_ competing for a _resource_ (for instance, a device or service) is defined. Informally, this system is characterized as follows:

* There is a set of stem:[m] _tokens_, stem:[m < n], used to grant _exclusive_ or _non-exclusive_ (_shared_) access to the resource.

* Depending on whether the desired access mode is exclusive or shared, an agent must own all tokens or one token, respectively, before the agent may access the resource.

* An agent is idle when not competing for a resource, waiting when trying to obtain access to the resource, or busy while owning the right to access the resource.

* Once an agent is waiting, it remains so until it obtains access to the resource.

* A busy agent releases the resource when it is no longer needed, as indicated by a stop condition for that agent that is externally set. On releasing the resource, all tokens owned by the agent are returned.

* Stop conditions are only indicated when an agent is busy. This is an integrity constraint on the behaviour of the external world.

* Initially, all agents are idle, and all tokens are available.

The system will be defined step by step, as the explanations of the ASM model proceed, starting with the basic ASM model with a single agent. The final ASM model of this system is summarized in <<example_the_system_rms>>.
====

[[basic_asm_model]]
==== Basic ASM model

[[overview]]
===== Overview

An abstract state machine (ASM) is a model of computation that treats first-order structures as dynamic entities whose states can change during a computation.

An abstract state machine has a set of states stem:[S], a subset of initial states stem:[S_0 sube S] and a function stem:[tau: S rarr S], called the one-step transformation. Every state is a first-order structure. All the states of an ASM have the same signature, which is also called the signature of the ASM, and all the states have the same base set, called the base set of the ASM. stem:[tau] does not change the base set, but it does, in general, change the equivalences that hold between terms of the signature.

The behaviour of an abstract state machine is modelled as a run or sequence of states. A run starts with an initial state, and each subsequent state is derived from its predecessor by application of the one-step transformation. Each application of the one-step transformation is called a move.

[%unnumbered]
[cols="8*^"]
|===
| | stem:[tau] | | stem:[tau] | | stem:[tau] | | _moves_
| stem:[s_0 in S_0]  | stem:[rarr] | stem:[s_1] | stem:[rarr] | stem:[s_2] | stem:[rarr] | stem:[...] | _states_
|===

[[states]]
===== States

The base set of the abstract state machine, which is the base set of every state of the ASM, contains three distinct elements: _true_, _false_ and _undefined_. The base set also contains an infinite number of _reserve elements_. A state also has functions and predicates that are defined over the base set. All functions are total, with _undefined_ being used to mimic partial functions. Predicates are functions whose only possible values are _true_ or _false_. Special unary predicates called _domain names_ identify members of the base set as belonging to particular _domains_. This allows states to be viewed as many-sorted structures.

Embedded within a state are certain substructures or _background classes_ <<b-Blass>> and <<b-Blass_2008>>. One such background includes _true_, _false_, the domain name _[smallcap]#Boolean#_ and the Boolean operators. The backgrounds used in modelling SDL-2010 include numbers, sets and sequences. A minimal background is defined in <<b-Blass>> and <<b-Blass_2008>> to characterize the ASMs that model parallel algorithms.

[[one_step_transformation]]
===== One-step transformation

The one-step transformation stem:[tau] updates the values of functions. In general, for stem:[s in S], some equivalences hold in stem:[s] but not in stem:[tau(s)] and vice versa. In some cases, τhas no effect, so stem:[s] and stem:[tau(s)] are the same.

To express the relationship between stem:[s] and stem:[tau(s)] more precisely, the changes effected by τare described in terms of an _update set_. An update set stem:[Delta] is a set of triples stem:[ < f,[a\],b >] where stem:[f] is a function symbol, stem:[[a\]] is a tuple of elements of the base set of the abstract state machine that respects the arity of stem:[f], and stem:[b] is an element of the base set. The relationship between stem:[s] and stem:[tau] is expressed by stating that stem:[Delta] contains all information of the form stem:[f [a\]= b] that is not true in the state stem:[s] but is true in stem:[tau(s)] <<b-Blass>>.

The pair stem:[< f, [a\] >] is also called a _location_ of a state stem:[s]. This captures the idea of updating the value of a variable in a conventional imperative programming language. A member stem:[<f, [a\], b>] of an update set is also known as an _update_ and may be written stem:[f [a\]:= b] to reinforce the idea of variable assignment.

An abstract state machine provides a model of computation for an algorithm that is expressed as a program using a programming-style syntax. The algorithm defines the update set for every state of the ASM. To facilitate the study of the kinds of algorithms captured by different kinds of ASM, axioms <<b-Blass>> have been developed to define classes of ASMs in a syntax-independent way [b-Glausch]. As well as capturing the ideas of state and one-step transformation outlined above (the Sequential Time and Abstract State postulates, <<b-Blass>> and <<b-Gurevich_2000>>), axioms aim to capture the idea that the amount of computation required to move from stem:[s] to stem:[tau(s)] must be bounded, where the bound depends only on the algorithm and not on the state.

[[specifying_an_abstract_state_machine]]
===== Specifying an abstract state machine

An ASM specification consists of a set of declarations that define its vocabulary (signature), its initial state(s) and a transition rule that defines the one-step transformation stem:[tau: S rarr S]. The transition rule, called the ASM program, is defined using a pseudo-code-like syntax based on terms of the signature.

[[specifying_the_signature_vocabulary]]
===== Specifying the signature (vocabulary)

An ASM signature comprises function names, predicate names and domain names. Names in the signature have a specified arity, and are interpreted over the base set of the states of an ASM. The interpretation of names respects their arity.

The following notational conventions are used when declaring names.

* _Domain names_ start with an uppercase letter and presented in small-capitalized italics (as in [smallcap]#_Agent_#), except when denoting a non-terminal of the SDL-2010 abstract grammar. In that case, domain names are written as the SDL-2010 non-terminals, i.e., in italics, hyphenated, and starting with an uppercase letter (as in _Agent-definition_). A domain name stem:[D] is declared by *domain* stem:[D]. A domain name is interpreted as a unary predicate which yields _true_ for the members of the base set that belong to the domain.

* _Function names_ are written in italics starting with a lowercase letter (as in _mode_). A function name stem:[f] is declared by stem:[f: D_1 xx D_2 xx ... xx D_n rarr D_0] , where stem:[n] is the arity of stem:[f], and stem:[D_0], stem:[D_1], stem:[D_2 ... D_n]  are domain names. A function name is interpreted as a function over the base set. The interpretation respects the arity of stem:[f].

* _Predicate names_ that are not _Domain names_ are also written in italics (as in _available_). A predicate name stem:[p] is declared by stem:[p: D_1 xx D_2 xx ... xx D_n ->] _[smallcap]#Boolean#_. A predicate is interpreted as a function whose value is either _true_ or _false_.

Declarations also include qualifiers, which specify further restrictions on their interpretation. Qualifiers on name declarations constrain interpretation of the one-step transformation.

* _Static names_ are qualified by the keyword *static*. A name that is declared static has the same interpretation in every state of an ASM. This means that the one-step transformation cannot update a static name. So the interpretation of a static domain name yields _true_ for the same elements in every state, and a static function name yields the same value for a given argument tuple in every state of an ASM.

* Dynamic names are qualified by one of the keywords *controlled*, *shared* or *monitored*. The one-step transformation can change the value of the interpretation of a dynamic name. A dynamic function can yield different values for a given set of arguments in different states of an ASM. An ASM can be subject to external environmental influences. ASM agents can communicate <<b-Glaesser_2007>>. When any of these situations is specified, the keywords *controlled*, *shared* and *monitored* constrain visibility and updates of domains, functions and predicates.

.The RMS Signature:
====
*static domain* [smallcap]#_Agent_# +
*static domain* [smallcap]#_Token_# +
*domain* [smallcap]#_Mode_#

*shared* _mode_: [smallcap]#_Agent_# stem:[rarr] _[smallcap]#Mode#_ +
*_controlled_* _owner_: [smallcap]#_Token_# stem:[rarr] _[smallcap]#Agent#_ +
*static* _ag_: stem:[rarr] [smallcap]#_Agent_# +

_idle_: [smallcap]#_Agent_# stem:[rarr] _[smallcap]#Boolean#_ +
_waiting_: [smallcap]#_Agent_# stem:[rarr] _[smallcap]#Boolean#_ +
_busy_: [smallcap]#_Agent_# stem:[rarr] _[smallcap]#Boolean#_ +
_available_: [smallcap]#_Token_# stem:[rarr] _[smallcap]#Boolean#_

*monitored* _stop_: [smallcap]#_Agent_# stem:[rarr] _[smallcap]#Boolean#_
====

The static domain names [smallcap]#_Agent_#, [smallcap]#_Token_# and [smallcap]#_Mode_# are introduced to represent the (single) agent of the system, the set of tokens, and the different access modes (exclusive, shared), respectively. The names _mode_ and _owner_ denote dynamic functions; they are used to model the current access mode of an agent and the current owner of a token, respectively. The 0-ary function name _ag_ refers to a value of the domain [smallcap]#_Agent_#. _idle_, _waiting_, _busy_, and _available_ are names of derived, dynamic predicates. _stop_ denotes a monitored predicate, which will be explained later.

The vocabularies we will consider also include _predefined names_, which include all the items in the background classes of the ASM. These include the equality sign, the 0-ary predicate names _true_, _false_ and _undefined_, the domain names _[smallcap]#Boolean#_, [smallcap]#_Nat_# and [smallcap]#_Real_#, as well as the names of frequently used standard functions (such as Boolean operations stem:[^^, vv, not, rArr, lArr], and set operations stem:[sube, uu, nn, in, !in], etc.). The full collection of predefined names is listed in <<predefined_names_and_special_symbols>>. Interpretation of predefined names is constrained to the usual meanings of those names.

The notational conventions described above enable declaration of _basic names_ that are interpreted directly over the ASM base set. As well as _basic names_, the signature of an ASM may include _derived names_, whose interpretation depends on the interpretation of the basic names. Derived names are defined using logical formulae involving other names. The interpretation of a derived name is determined by the interpretations of those other names, and ultimately by the interpretation of base names.

Let _derivedName_ be an n-ary name, and let _formula_(stem:[v_1,..., v_n]) denote a formula of the domain stem:[D] with free variables stem:[v_1,..., v_n]  of domains stem:[D_1,..., D_N, n >= 0]. The general form of a _derived name definition_ is:

[pseudocode]
[%unnumbered]
====
_derivedNameDefinition ::= derivedName(v~1~: D~1~, ..., v~n~: D~n~):D_ =~def~ _formula (v~1~,..., v~n~)_
====

The result domain stem:[D] is omitted in case of a derived domain definition.

.Derived names for the _RMS_ specification
====
The following derived predicates are defined to refer to the status of an agent/token in a given state.

[pseudocode]
[%unnumbered]
=====
[smallcap]#_Mode_# =~def~  {_exclusive_, _shared_} +
_idle(a:_ [smallcap]#_Agent_#): _[smallcap]#Boolean#_ =~def~ _a.mode_ = _undefined_ stem:[^^ AA t in] [smallcap]#_Token_#: _t.owner_ stem:[!=] _a_ +
_waiting(a:_ [smallcap]#_Agent_#): _[smallcap]#Boolean#_ =~def~           _a.mode_ stem:[!=] _undefined_ stem:[^^ AA t in] [smallcap]#_Token_#: _t.owner_ stem:[!=] _a_ +
_busy(a:_ [smallcap]#_Agent_#): [smallcap]#_Boolean_# =~def~            _a.mode_ stem:[!=] _undefined_ stem:[^^ EE t in] [smallcap]#_Token_#: _t.owner_ = _a_ +
_available (t: [smallcap]#Token#): [smallcap]#Boolean#_ =~def~          _t.owner_ = _undefined_
=====

====

An agent _a_ is, for instance, idle if the function _mode_ yields the value _undefined_ for that agent, and _a_ does not hold any token. A token stem:[t] is available if no agent is holding stem:[t].

For an improved readability, use of the "." _-notation_ is allowed for unary functions and predicates. For instance, _a.mode_ is equivalent to _mode_(_a_).

[[initial_states]]
===== Initial states

The set of _initial states_ stem:[S_0 sube S] is defined by constraints imposed on domains, functions and predicates as associated with the names in stem:[V]. The initial constraints for predefined domains and operations are given implicitly (see <<predefined_names_and_special_symbols>>). Initial constraints have the following general form:

[pseudocode]
[%unnumbered]
====
*initially* _ClosedFormula_
====

.Initial states:
====
The following constraints define the set of initial states of the system _RMS_.

*initially* [smallcap]#_Agent_# = _{ag}_ +
*initially* stem:[AA a in] [smallcap]#_Agent_#: _a.idle_ stem:[^^ AA t in] [smallcap]#_Token_#: _t.available_
====

The first constraint defines the initial set [smallcap]#_Agent_# to consist of a single element _ag_. The second constraint expresses that initially, the agent of _RMS_ is idle _(a.mode = undefined)_, and all tokens are available _(t.owner = undefined)_. Note that no constraint on _stop_ is defined.

[[state_transitions_and_runs]]
===== State transitions and runs

A (global) state stem:[s in S] is given by an interpretation of the names in stem:[V] over the base set of stem:[M]. State transitions can be defined in terms of partial reinterpretations of dynamic domains, functions and predicates. This gives rise to the notions of _location_ as a conceptual means to refer to parts of global states, and of _update_ to describe state changes.

A _location of a state_ stem:[s] _of_ stem:[M] is a pair stem:[loc_s  = <f, s(x)>], where stem:[f] is a dynamic name in stem:[V], and stem:[s(x)] is a sequence of elements of the base set according to the arity of stem:[f]. An _update of s_ is a pair stem:[delta_s = <loc_s, s(y)>], where stem:[s(y)] identifies an element of the base set as the new value to be associated with the location stem:[loc_s]. To _fire_ stem:[delta_s] means to transform stem:[s] into a state stem:[s'] of stem:[M] such that stem:[f_{s'} (s(x)) = s(y)], while all other locations stem:[loc_s'] of stem:[s], stem:[loc_s' != loc_s], remain unaffected. In other words, firing an update modifies the interpretation of a state in a well-defined way.

The potential behaviour of a basic ASM is captured by a _program_ stem:[P], which is defined by a _transition rule_ (see <<transition_rules>> and <<asm_programs>>). For each state stem:[s in S], a program stem:[P] of stem:[M] defines an _update set_ stem:[Delta_s(P)] as a finite set of updates of stem:[s]. stem:[Delta_s(P)] is _consistent_, if and only if it does not contain any two updates stem:[delta_s,  delta'_s] such that stem:[delta_s = < loc_s,  s(y) >], stem:[delta'_s = < loc_s,  s(y') >], and stem:[s(y) != s(y')]. The _firing of a consistent update set_ stem:[Delta_s (P)] in state stem:[s] means to fire all its members simultaneously, i.e., to produce (in one atomic step) a new state stem:[s'] such that for all locations stem:[loc_s = <f,  s(x)>] of stem:[s], stem:[f_{s'} (s(x)) = s(y)], if stem:[< < f,  s(x) >,  s(y) > in Delta_s (P)], and stem:[f_{s'} (s(x)) = f_s (s(x))] otherwise, and is called _state transition_. Firing an inconsistent update set has no effect, i.e., stem:[s' = s].

NOTE: In the context of the SDL-2010 semantics, an inconsistent update set indicates an error in the semantic model. The ASM semantics ensures that such errors do not destroy the notion of state.

The behaviour of a single-agent ASM stem:[M] is modelled through (finite or infinite) _runs of_ stem:[M], where a _run_ is a sequence of state transitions of the form:

[%unnumbered]
[cols="8*^"]
|===
| | stem:[Delta_{s0} (P)] | | stem:[Delta_{s1} (P)] | | stem:[Delta_{s2} (P)] | |  _moves_
| stem:[s_0] | stem:[rarr] | stem:[s_1] | stem:[rarr] | stem:[s_2] | stem:[rarr] | ... |  _states_
|===

such that stem:[s_0 in S_0], and stem:[s_{i+1}] is obtained from stem:[s_i], for stem:[ i >= 0], by firing stem:[Delta_{si} (P)] on stem:[s_i], where stem:[Delta_{si} (P)] denotes an update set defined by the program stem:[P] of stem:[M] on stem:[s_i] (see <<asm_programs>>). The meaning of an ASM is defined to be the set of all its runs. In the sequel, we restrict attention to runs starting in an initial state, also called _regular runs_.

[[transition_rules]]
===== Transition rules

Transition rules specify update sets over ASM states. Complex rules are formed from elementary rules using various rule constructors. The elementary form of transition rule is called _update instruction_.

* _update_ instruction

[pseudocode]
[%unnumbered]
====
_Rule ::= f(t1,...,tn) := t0_ (stem:[n >= 0])
====

Here, stem:[f] is a non-static name of stem:[V] denoting either a controlled or a shared function, predicate or domain, and stem:[t_0, t_1 , ..., t_n] are terms over stem:[V] identifying, for a given state stem:[s], the location stem:[ loc = < f, < s(t_1), ..., s(t_n) > >] to be changed and the new value stem:[s(t_0)] to be assigned, respectively. In other words, the above update instruction specifies the update set stem:[{< < f, < s(t_1),..., s(t_n) > >, s(t_0) > }], consisting of a single update. Note that only locations related to (non-static) basic names may occur at the left-hand side of an update instruction.

.Update instruction:
====
Let stem:[t] be a variable denoting a token and _ag_ be an agent.

_t.owner := ag_ specifies the update set {stem:[< < owner, < s(t) > >,  s(ag) >]} +
_ag.mode := undefined_ specifies the update set {stem:[ < < mode, < s(ag) > >, s] _(undefined)_ >}
====

The construction of complex transition rules out of elementary update instructions is recursively defined by means of _ASM rule constructors_. For the ASM model applied to define the SDL-2010 semantics, six different constructors (*if-then*, *do-in-parallel*, *do-forall*, *choose*, *extend*, *let*) are used. These constructors are listed below, with an informal description of their meaning. Here, _Rule_,  _Rule~i~_ denote transition rules, stem:[g] denotes a Boolean term, and stem:[v, v_1,..., v_n] denote free variables over the base set of stem:[M]. The scope of a rule constructor is expressed by appropriate keywords, and can additionally be indicated by indentation. The closing keywords can be omitted, if no confusion arises. If closing keywords are omitted, the corresponding constructor extends as much as possible, but not over the next *where*-clause.

* _if-then-constructor_

[pseudocode]
[%unnumbered]
====
_Rule_ ::= *if* _g_ *then* +
            _Rule~1~_ +
            [*else* +
            _Rule~2~_] +
            *endif*
====

The update set specified by _Rule_ in a given state stem:[s] is defined to be the update set of _Rule~1~_ or _Rule~2~_, depending on the value of stem:[g] in state stem:[s]. Without the optional *else*-part, the update set defined by _Rule_ is the update set of _Rule~1~_ or the empty update set. Sometimes, *elseif* is used as abbreviation for *else if*.

* _do-in-parallel-constructor_

[pseudocode]
[%unnumbered]
====
_Rule_ ::= *do in-parallel* +
            _Rule~1~_ +
            ... +
            _Rule~n~_ +
            [*enddo*]
====

The update set defined by _Rule_ in state stem:[s] is defined to be the union of the update sets of _Rule~1~_ through _Rule~n~_. In other words, the order in which transition rules belonging to the same block are stated is irrelevant. For brevity, the keywords *do in-parallel* and *enddo* may be omitted, where no confusion arises. Hence, an ASM program often appears as a collection of rules rather than a monolithic block rule.

* _do-forall-constructor_

[pseudocode]
[%unnumbered]
====
_Rule_ ::= *do forall* _v: g(v)_ +
                _Rule~0~ (v)_ +
         *enddo*
====

The effect of _Rule_ is that _Rule~0~_ is fired simultaneously for all elements _v_ of the base set of stem:[M] for which the Boolean condition stem:[g(v)] holds in state stem:[s], where _v_ is a free variable _in_ _Rule~0~_. _More precisely_, stem:[Delta_s ("Rule")] is the union of all update sets stem:[Delta_s] _(Rule~0~(v))_ such that stem:[g(v)] holds in state stem:[s]. Recall that update sets are required to be finite; therefore, stem:[g(v)] must hold for a finite number of values only.

* _choose-constructor_

[pseudocode]
[%unnumbered]
====
_Rule_ ::=  *choose* _v: g(v)_ +
                _Rule~0~ (v)_ +
          *endchoose*
====

The effect of _Rule_ is that _Rule~0~_ is fired for an element _v_ of the base set of stem:[M] for which the condition stem:[g(v)] holds in state stem:[s], where _v_ is a free variable _in_ _Rule~0~_. _More precisely_, stem:[Delta_s ("Rule")] _is some update set_ stem:[Delta_s] _(Rule~0~(v))_ _such that_ stem:[g(v)] holds in state stem:[s], or the empty update set if no such _v_ exists.

* _extend-constructor_

[pseudocode]
[%unnumbered]
====
_Rule_ ::= *extend* _D_ *with* _v~1~,...,v~n~_ +
           _Rule~0~ (v~1~,..., v~n~)_ +
            *endextend*
====

The effect of _Rule_ when fired at state stem:[s] is that stem:[n] reserve elements of stem:[s] (see <<states>>) are imported into the dynamic domain stem:[D] (while being removed from the reserve), that stem:[v_1,...,v_n] become bound to one of the imported elements each, and then _Rule~0~_ stem:[(v_1,..., v_n)] _is fired_.

The _extend_ constructor can be used to mimic object-based ASM definitions, where objects are dynamically created. Thus, for each object to be created, an element from the reserve is assigned to the corresponding domain, and initialized.

NOTE: _extend_ can be defined in terms of the _import_ constructor (not shown here); however, the _import_ constructor is not used in the formal definition of SDL-2010.

* _let-constructor_

[pseudocode]
[%unnumbered]
====
_Rule_ ::= *let* _v = expression_ *in* +
               _Rule~0~ (v)_ +
         *endlet*
====

The effect of _Rule_ when fired in some state stem:[s] is that _v_ is bound to the value of _expression_, and that _Rule~0~_  is fired with this value.

.Transition rule with if-then and choose:
====
The following transition rule defines the behaviour of agent _ag_ when requesting shared access, i.e., when _ag.mode_ = _shared_. The rule applies the if-then-constructor, the choose-constructor, and an update instruction.

[pseudocode]
[%unnumbered]
======
*if* _ag.mode_  = _shared_  stem:[^^] _ag.waiting_ *then* +
    *choose* t: t  stem:[in] [smallcap]#_Token_# stem:[^^] _t.available_ +
        _t.owner_:= ag +
    *endchoose* +
*endif*
======

====

The precise meaning of the rule is given by its update set with respect to a state stem:[s], which is either {stem:[< < owner, < s(t) > >, s(ag) >]} for some token stem:[s(t)] available in stem:[s], if all further predicates stated in the if-then-constructor hold in stem:[s], or the empty update set otherwise.

[[abbreviations]]
// To avoid this being recognised as abbreviations
[heading="Abbreviation Clause"]
===== Abbreviations

Rules can be structured using _abbreviations_, consisting of _rule macros_ and _derived names_, which may have parameters. This allows for hierarchical definitions, and the stepwise refinement of complex rules, which supports the understanding of ASM model definitions.

Derived names are introduced (as explained in <<specifying_the_signature_vocabulary>> and <<derived_names>>), i.e., by declaration and definition, or alternatively, in the compact form, by combining declaration and definition.

* _rule-macro_-definition

Let _Rule~0~_  denote a transition rule with free variables stem:[v_1 ,..., v_n] _of domains_ stem:[D_1,...,  D_N,  n >= 0]. The general form of a rule macro definition is:

[pseudocode]
[%unnumbered]
====
_RuleMacroDefinition_::= _RuleMacroName(v~1~: D~1~,...,v~n~: D~N~) stem:[-=]_
                                _Rule~0~ (v~1~,...,v~n~)_
====

Rule macro names are, by convention, written in small capitals, with a leading capital letter (as in [smallcap]#SharedAccess#).

* _where_-part

By default, _rule macros_ and _derived names_ have a global scope. However, their scope can also be restricted to a particular transition rule _Rule_ by using the where-part.

[pseudocode]
[%unnumbered]
====
_Rule ::= Rule~0~_ +
*where* +
    _(RuleMacroDefinition | DerivedNameDefinition)^+^_ +
*endwhere*
====

* _rule-macro_-constructor

Rule macros are applied in transition rules as follows:

[pseudocode]
[%unnumbered]
====
_Rule_ ::= _RuleMacroName (t~1~,...,t~n~)_
====

Formally, rule macros are syntactical abbreviations, i.e., each occurrence of a macro in a rule is to be replaced textually by the related macro definition (replacing formal parameters by actual parameters).

.Rule macro:
====
The transition rule from the previous example can be stated using rule macros, and be defined as a macro itself. Here, [smallcap]#SharedAccess# is a macro definition with global scope that can be used in other places of the ASM model definition. [smallcap]#GetToken# is a parameterized macro definition with a local scope restricted to the rule [smallcap]#SharedAccess#, with formal parameter _a_. When [smallcap]#GetToken# is applied in [smallcap]#SharedAccess#, _a_ is replaced by the actual parameter _ag_.

[pseudocode]
[%unnumbered]
=====
[smallcap]#SharedAccess# stem:[-=] +
    *if* _ag.mode_ = _shared_ stem:[^^] _ag.waiting_  *then* +
        [smallcap]#GetToken#(_ag_) +
    *endif* +
    *where* +
        [smallcap]#GetToken# _(a: [smallcap]#Agent#)_ stem:[-=] +
        *choose* _t: t_ stem:[in] _[smallcap]#Token#_ stem:[^^] _t.available_ +
            _t.owner:= a_ +
        *endchoose* +
    *endwhere*
=====

====

[[asm_programs]]
===== ASM programs

An _ASM program_ stem:[P] is given by a framed _transition rule_ (or _rule_ for short) of the following form:

[pseudocode]
[%unnumbered]
====
_Rule_
====

As already mentioned, rule macro definitions may either have a local or a global scope. To have a global scope, the macro definitions can be given outside the ASM program and can thus also be applied in the ASM program.

In the basic ASM model there is just one ASM program, which is statically associated with an implicitly defined agent executing this program. The next clause allows several ASM programs to be defined and associated with different agents that are introduced dynamically during abstract machine runs.

.ASM program:
====
The ASM program stem:[P] of the system _RMS_ is defined as follows:

[pseudocode]
[%unnumbered]
=====
*do in-parallel* +
    [smallcap]#SharedAccess# +
    [smallcap]#ExclusiveAccess# +
    [smallcap]#ReleaseAccess# +
*enddo* +
*where*

[smallcap]#SharedAccess# stem:[-=] +
    *if* _ag.mode_ = _shared_ stem:[^^] _ag.waiting_ *then* +
        *choose* _t: t_ stem:[in] _[smallcap]#Token#_ stem:[^^] _t.available_ +
            _t.owner_:= _ag_ +
        *endchoose* +
    *endif* +
[smallcap]#ExclusiveAccess# stem:[-=] +
    *if* _ag.mode_ = _exclusive_ stem:[^^ AA t in] [smallcap]#Token#: _t.available_ *then* +
        *do forall* _t: t_ stem:[in] [smallcap]#_Token_# +
            _t.owner_:= _ag_ +
        *enddo* +
        *endif* +
[smallcap]#ReleaseAccess# stem:[-=] +
    *if* _ag.busy_ stem:[^^] _ag.stop_ *then* +
        *do in-parallel* +
            _ag.mode_:= _undefined_ +
            *do forall* _t: t_ stem:[in] [smallcap]#_Token_# stem:[^^] _t.owner_ = _ag_ +
                _t.owner_:= _undefined_ +
            *enddo* +
        *enddo* +
    *endif* +
*endwhere*
=====

====

The ASM program is defined by a single transition rule as shown in the frame. The transition rule uses the do-in-parallel-constructor and 3 rule macros, which results in a hierarchical rule definition.

[[distributed_multi_agent_asm]]
==== Distributed multi-agent ASM

Mathematical modelling of concurrent and reactive systems requires more than the basic ASM model described above. This section presents the concept of a _distributed ASM_ operating in _parallel_ with its external environment, where the environment behaves as one or more ASMs.

A _distributed Abstract State Machine_ stem:[M] is defined over a given _vocabulary_ stem:[V] by its _states_  stem:[S], its _initial states_ stem:[S_0 sube S], its agents stem:[A], and its _programs_ stem:[P]. These items will be explained in the following subclauses insofar as they differ from the basic ASM model.

[[signature]]
===== Signature

The signature (vocabulary) stem:[V] of a multi-agent ASM stem:[M] includes distinguished domain names:

[pseudocode]
[%unnumbered]
====
*controlled domain* [smallcap]#_Agent_# +
*static domain* [smallcap]#_Program_#
====

representing _a dynamic_ set stem:[A] of agents and an invariant set stem:[P] of ASM programs, respectively. [smallcap]#_Agent_#, [smallcap]#_Program_# and _program_: [smallcap]#_Agent_# stem:[rarr] [smallcap]#_Program_# constitutes further _background classes_.

Furthermore, stem:[V] includes a distinguished function name:

[pseudocode]
[%unnumbered]
====
*controlled* _program_: [smallcap]#_Agent_# stem:[rarr] [smallcap]#_Program_#
====

and a special 0-ary function _Self_ (see <<agents_and_runs>>), whose interpretation is different for each agent.

[[agents_and_runs]]
===== Agents and runs

A multi-agent, distributed ASM has a finite number of agents. Agents can be created and destroyed dynamically. Each agent executes its own basic ASM. The behaviour of each agent is determined by a program, which is defined by a transition rule. The association between agents and their behaviour is specified by the background function _program_: [smallcap]#_Agent_# stem:[rarr] [smallcap]#_Program_#. This function can be updated, allowing agents' behaviour to be modified dynamically, and allowing behaviour to be assigned to newly created agents.

Agents operate concurrently and interact by sending messages to one another (see <<b-Blass>> and [ITU-T Z.101]). More precisely, agents interact by updating locations that are accessible to other agents. Agents can act as [smallcap]#_Communicators_# <<b-Glaesser>>, whose behaviour is to read input locations, transform the values read, and update output locations that can be read by other agents. In this way messages can be passed asynchronously between agents without the original source or the final destination necessarily having a commonly accessible location. Agents also interact with an external environment, which can be viewed as an agent in its own right, or as a collection of agents.

A multi-agent distributed ASM is formed by combining its constituent single-agent ASMs. Like a single agent ASM, it has a set states stem:[S], a subset of initial states stem:[S_0 sube S] and a function stem:[tau: S rarr S], called the one-step transformation.

To assign a behaviour to an agent of stem:[M], the distinguished function _program_ (see <<signature>>) yields (for each agent _a_ of _M_) the program of stem:[P] to be executed by _a_. The function _program_ thus allows the definition (or redefinition) of the behaviour of agents dynamically; it is thereby possible to create new agents at run time. In a given state *_s_* of stem:[M], the agents of stem:[M] are all those elements _a_ of s such that _a.program identifies_ a behaviour (asdefined by some program of _P_) to be associated with _a_.

A special 0-ary function _Self_ serves as a _self-reference_ identifying the respective agent calling _Self_:

[pseudocode]
[%unnumbered]
====
*monitored* _Self_: stem:[rarr] [smallcap]#_Agent_#
====

For every agent, _Self_ has a different interpretation. By using _Self_ as an additional function argument, each agent _a_ can have its own partial view of a given global state of stem:[M] on which it fires the rule in _a.program_.

.Scheme of a distributed ASM
====
In the following figure, a particular distributed ASM stem:[M], consisting of three agents stem:[ag_1], stem:[ag_2], and stem:[ag_3] is illustrated. The function _program_ associates, with each agent, one of the ASM programs stem:[P_1], stem:[P_2], and stem:[P_3]. Here, stem:[ag_1] and stem:[ag_2] are assigned the same program. Program stem:[P_2] is currently not associated with any agent; however, this may change during execution, as _program_ is a dynamic function. Each agent has its own _partial view_ on a given global state stem:[s] of stem:[M], in which it fires the rule of its current program. In the figure, this view is illustrated by the function _view_, which yields, for each agent, its local and its shared state. In fact, the current view of each agent is determined implicitly by the ASM model definition, including the ASM programs.

The semantic model of concurrency underlying the distributed ASM model defines behaviour in terms of partially ordered runs. A _partially ordered run_ represents a certain class of (admissible) machine runs by restricting non-determinism with respect to the order in which the individual agents may perform their computation steps, so-called _moves_. To avoid that agents interfere with each other, moves of different agents need only be ordered if they are causally dependent (as detailed below).

*Partially ordered runs*

Regarding the moves of an individual agent, these are linearly ordered, whereas moves of different agents need only be ordered in case they are not _independent_ of each other. Intuitively, independent moves model concurrent actions that are incomparable with regard to their order of execution. The precise meaning of independence is implied by the coherence condition in the formal definition of partially ordered runs <<b-Gurevich>>.

A run stem:[rho] of a distributed ASM stem:[M] is given by a triple stem:[(^^,A,sigma)] satisfying the following four conditions:

. stem:[^^] is a partially ordered set of moves, where each move has only a finite number of predecessors;

. stem:[A] is a function on Λ associating agents to moves such that the moves of any single agent of stem:[M] are linearly ordered;

. σ assigns a state of stem:[M] to each initial segment stem:[Y] of Λ, where stem:[sigma(Y)] is the result of performing all moves in _Y_; if stem:[Y] is empty, then stem:[sigma(Y) in S_0];

. if stem:[y] is a maximal element in a finite initial segment stem:[Y] of stem:[^^] and stem:[Z = Y - { y }], then stem:[A(y)] is an agent in stem:[sigma(Z)] and stem:[sigma(Y)] is obtained from stem:[sigma(Z)] by firing stem:[A(y)] at stem:[sigma(Z)] (_coherence condition_).

*Implications*

Partially ordered runs have certain characteristic properties that can be stated in terms of _linearizations_ of partially ordered sets. A linearization of a partially ordered set stem:[^^] is a linearly ordered set stem:[^^'] with the same elements such that if stem:[y < z] in stem:[^^] then stem:[y < z] in stem:[^^']. Accordingly, the semantic model of concurrency (as implied by the notion of a partially ordered run) can further be characterized as follows <<b-Gurevich>>:

* All _linearizations_ of the same finite initial segment of a run of stem:[M] have the same final state.

* A property holds in every reachable state of a run stem:[rho] of stem:[M] if and only if it holds in every reachable state of every linearization of stem:[rho].
====

[[fig-f1-3]]
.Each agent has a partial view of the global ASM state
image::Z.100-201811-AnnF1/image5.png[]

[[distributed_asm_programs]]
===== Distributed ASM programs

A distributed _ASM M_ has a finite set stem:[P] of programs. Eachprogram stem:[p in P] is given by a _program name_ and a _transition rule_ (or _rule_ for short). The program name uniquely identifies stem:[p] within stem:[P], and is represented by a unary static function. Programs are stated in the following form:

[smallcap]#Asm-Program#:
[pseudocode]
[%unnumbered]
====
_Rule_
====

NOTE: Strictly, the program names of M are represented by a distinguished set of elements from the base set.

Program names are, by convention, hyphenated and written in small capitals, with a leading uppercase letter (as in [smallcap]#Resource-Management-Program#).

By default, the following implicit constraint applies:

[pseudocode]
[%unnumbered]
====
*initially* [smallcap]#_Program_# = {[smallcap]#program#~1~ ,..., [smallcap]#program#~n~ }
====

where [smallcap]#program#~1~ ,..., [smallcap]#program#~N~  are the names of the programs that are defined in the ASM model.

.ASM program
====
The distributed ASM program of the system _RMS_ defines a single program as follows:

[pseudocode]
[%unnumbered]
=====
[smallcap]#Resource-Management-Program#: +
*do in-parallel* +
    [smallcap]#SharedAccess# +
    [smallcap]#ExclusiveAccess# +
    [smallcap]#ReleaseAccess# +
*enddo* +
*where* +
        [smallcap]#SharedAccess# stem:[-=] +
            *if* _Self.mode_ = _shared_ stem:[^^] _Self.waiting_ *then* +
                *choose* _t: t_ stem:[in] [smallcap]#_Token_# stem:[^^] _t.available_ +
                    _t.owner_:= _Self_ +
                *endchoose* +
            *endif* +
        [smallcap]#ExclusiveAccess# stem:[-=] +
            *if* _Self.mode_ = _exclusive_ stem:[^^] stem:[AA t] stem:[in] [smallcap]#_Token_#: _t.available_ *then* +
                *do forall* _t: t_ stem:[in] [smallcap]#_Token_# +
                    _t.owner_:= _Self_ +
                *enddo* +
            *endif* +
        [smallcap]#ReleaseAccess# stem:[-=] +
            *if* _Self.busy_ stem:[^^] _Self.stop_ *then* +
                *do in-parallel* +
                    _Self.mode_:= _undefined_ +
                    *do forall* _t: t_ stem:[in] [smallcap]#_Token_# stem:[^^] _t.owner_ = _Self_ +
                        _t.owner_:= _undefined_ +
                    *enddo* +
                *enddo* +
            *endif* +
*endwhere*
=====

====

The program of the distributed ASM has the name Resource-Management-Program, and is defined as the single-agent ASM program before, with one difference: all occurrences of _ag_ have been replaced by calls of the function _Self_. This allows the association of the program with different agents, while accessing the local state of these agents.

[[the_external_world]]
==== The external world

Following an _open system view_, interactions between a system and the external world, e.g., the environment into which the system is embedded, are modelled in terms of various interface mechanisms. Regarding the reactive nature of distributed systems, it is important to clearly identify and precisely state:

* preconditions on the expected behaviour of the external world; and

* how external conditions and events affect the behaviour of an ASM model.

This is achieved through a classification of _dynamic_ ASM names into three basic categories of names, which extends the classification of names shown in <<fig-f1-3>>:

* _controlled names_

These domains, functions or predicates can only be modified by agents of the ASM model, according to the executed ASM programs. Controlled names are preceded by the keyword *controlled* at their point of declaration, and are visible to the environment. See <<fig-f1-3>>.

* _monitored names_

These domains, functions or predicates can only be modified by the environment, but are visible to ASM agents. Thus, a monitored domain, function or predicate may change its values from state to state in an unpredictable way, unless this is restricted by _integrity constraints_ (see below). Monitored names are preceded by the keyword *monitored* at their point of declaration. See <<fig-f1-3>>.

* _shared names_

These domains, functions or predicates are visible to and may be altered by the environment as well as by the ASM agents. Therefore, an _integrity constraint_ on shared domains, functions or predicates is that no interference with respect to mutually updated locations must occur. Hence, it is required that the environment itself acts like an ASM agent (or a collection of ASM agents). Shared names are preceded by the keyword *shared* at their point of declaration. See <<fig-f1-4>>.

[[fig-f1-4]]
.Extended classification of ASM names
====
*External world*

The vocabulary stem:[V] of the system _RMS_ is extended by a classification of dynamic functions and predicates:

[pseudocode]
[%unnumbered]
=====
*shared* _mode_:           [smallcap]#_Agent_# stem:[rarr] [smallcap]#_Mode_# +
*controlled* _owner_:      [smallcap]#_Token_# stem:[rarr] [smallcap]#_Agent_# +
*monitored* _stop_:        [smallcap]#_Agent_# stem:[rarr] [smallcap]#_Boolean_#
=====

The function _mode_, which determines the current access mode, is shared. It may be affected by externally controlled 'set' operations, switching it to one of the values _exclusive_ or _shared_. Furthermore, it is reset internally when the resource is released (see <<distributed_asm_programs>>).

The predicate _stop_ represents an external stop request, such as an interrupt, and therefore is monitored.
====

In general, the influence of the environment on the system through shared and monitored names may be completely unpredictable. However, preconditions on the expected environment behaviour may be expressed by stating _integrity constraints_, which are required to hold in _all_ states and runs of stem:[M]. Note that integrity constraints merely express preconditions on the environment behaviour, but _not_ properties the system is supposed to have.

Integrity constraints are stated in the following form:

[pseudocode]
[%unnumbered]
====
_IntegrityConstraint_ ::= *constraint* _ClosedFormula_
====

.Integrity constraints:
====
//*Integrity constraints:*

The following integrity constraint states that stop requests are only generated for busy agents:

[pseudocode]
[%unnumbered]
=====
*constraint* stem:[AA a in] [smallcap]#_Agent_#: (_a.stop_stem:[=>]_a.busy_)
=====

====

[[real_time_behaviour]]
==== Real-time behaviour

By introducing a notion of _real time_ and imposing additional constraints on runs, we obtain a specialized class of ASMs, called _distributed real-time ASM_, with agents performing _instantaneous_ actions in _continuous_ time. Essentially, that means that agents fire their rules at the moment they are enabled.

To incorporate real-time behaviour into the underlying ASM execution model, we introduce a 0-ary monitored real-valued function _currentTime_. Intuitively, _currentTime_ refers to the physical time. As an integrity constraint on the nature of physical time, it is assumed that _currentTime_ changes its values monotonically increasing over ASM runs.

[pseudocode]
====
*monitored* _currentTime_: stem:[rarr] [smallcap]#_Real_#
====

Consider a given vocabulary stem:[V] containing [smallcap]#_Real_# (but not _currentTime_) and let stem:[V^\+] be the extension of stem:[V] with the function symbol _currentTime_. Restrict attention to stem:[V^+] -states where _currentTime_ evaluates to a real number. One can then define a run stem:[R] of the resulting machine model as a mapping from the interval [0,∞) to states of vocabulary stem:[V^+] satisfying the following _discreteness requirement_:

. for every stem:[t >= 0], _currentTime_ evaluates to stem:[t] at state stem:[R(t)];

. for every stem:[tau > 0], there is a finite sequence stem:[0 = t_0 < t_1 < ... < t_n = tau] such that if stem:[t_i < alpha < beta < t_{i+1}]  then stem:[sigma(alpha) = sigma(beta)].

where the reduct of stem:[R(t)] to stem:[V] is denoted by stem:[sigma(t)] such that for a given value stem:[t], stem:[sigma(t)] is derived from stem:[R(t)] by ignoring the interpretation of the function name _currentTime_.

Exploiting the discreteness property, one effectively obtains some finite representation (_history_) for every finite (sub-) run by abstracting from those states that do not differ in any significant way from their neighbouring states. In particular, one can simply ignore all states that are identical to their preceding state except that _currentTime_ has increased. From the above definition of run it follows that only finitely many states are left.

[[example_the_system_rms]]
==== Example: The system _RMS_

In this clause, we assemble the pieces of the ASM model definition of the system _RMS_ into their final version. For completeness, we also repeat the informal description.

[[informal_description]]
===== Informal description

In order to illustrate the ASM model, a simple resource management system _RMS_ consisting of a group of stem:[n > 1] _agents_ competing for a _resource_, for instance, a device or service, is defined. Informally, this system is characterized as follows:

* There is a set of stem:[m] _tokens_, stem:[m < n], used to grant _exclusive_ or _non-exclusive_ (_shared_) access to the resource.

* Depending on whether the desired access mode is exclusive or shared, an agent must own all tokens or one token, respectively, before he may access the resource.

* An agent is _idle_ when not competing for a resource, _waiting_ when trying to obtain access to the resource, or _busy_ when owning the right to access the resource.

* Once an agent is _waiting_, it remains so until it obtains access to the resource.

* A busy agent releases the resource when it is no longer needed, as indicated by a _stop condition_ for that agent that is externally set. On releasing the resource, all tokens owned by the agent are returned.

* Stop conditions are only indicated when an agent is busy.

* Initially, all agents are idle, and all tokens are available.

[[vocabulary]]
===== Vocabulary

[pseudocode]
[%unnumbered]
====
*static domain* [smallcap]#_Token_# +
*shared* _mode_: [smallcap]#_Agent_# stem:[rarr] [smallcap]#_Mode_# +
*controlled* _owner_: [smallcap]#_Token_# stem:[rarr] [smallcap]#_Agent_# +
*monitored* _stop_: [smallcap]#_Agent_# stem:[rarr] [smallcap]#_Boolean_#
====

[[derived_names]]
===== Derived names

[pseudocode]
[%unnumbered]
====
[smallcap]#_Mode_#                  =~def~ {_exclusive_, _shared_}
_idle (a: [smallcap]#Agent#): [smallcap]#Boolean#_     =~def~ _a.mode_ = _undefined_ stem:[^^ AA t in] [smallcap]#_Token_#: _t.owner_ stem:[!=] _a_
_waiting (a: [smallcap]#Agent#): [smallcap]#Boolean#_   =~def~ _a.mode_ stem:[!=] _undefined_ stem:[^^] stem:[AA t] stem:[in] [smallcap]#_Token_#: _t.owner_ stem:[!=] _a_
_busy (a: [smallcap]#Agent#): [smallcap]#Boolean#_     =~def~ _a.mode_ stem:[!=] _undefined_ stem:[^^ EE] _t_ stem:[in] [smallcap]#_Token_#: _t.owner_ = _a_
_available (t: [smallcap]#Token#): [smallcap]#Boolean#_ =~def~ _t.owner_ = _undefined_
====

[[integrity_constraints]]
===== Integrity constraints

[pseudocode]
[%unnumbered]
====
*constraint* stem:[AA a in] [smallcap]#_Agent_#: (_a.stop_ stem:[=>] _a.busy_)
====

[[initial_constraints]]
===== Initial constraints

[pseudocode]
[%unnumbered]
====
*initially* |[smallcap]#_Agent_#| > 1 +
*initially* |[smallcap]#_Token_#| < |[smallcap]#_Agent_#| +
*initially* stem:[AA] _a_ stem:[in] [smallcap]#_Agent_#: _a.program_ = [smallcap]#Resource-Management-Program# +
*initially* stem:[AA] _a_ stem:[in] [smallcap]#_Agent_#: _a.idle_ stem:[^^] stem:[AA] _t_ stem:[in] [smallcap]#_Token_#: _t.available_
====

[[the_system_rms_asm_programs]]
===== ASM programs

[smallcap]#Resource-Management-Program#

[pseudocode]
[%unnumbered]
====
*do in-parallel* +
    [smallcap]#SharedAccess# +
    [smallcap]#ExclusiveAccess# +
    [smallcap]#ReleaseAccess# +
*enddo* +
*where* +
    [smallcap]#SharedAccess# stem:[-=] +
        *if* _Self.mode_ = _shared_ stem:[^^] _Self.waiting_ *then* +
            *choose* _t: t_ stem:[in] [smallcap]#_Token_# stem:[^^] _t.available_ +
                _t.owner_:= _Self_ +
            *endchoose* +
        *endif* +
    [smallcap]#ExclusiveAccess# stem:[-=] +
        *if* _Self.mode_ = _exclusive_ stem:[^^ AA] _t_ stem:[in] [smallcap]#_Token_#: _t.available_ *then* +
            *do forall* _t: t_ stem:[in] [smallcap]#_Token_# +
                _t.owner_:= _Self_ +
            *enddo* +
        *endif* +
    [smallcap]#ReleaseAccess# stem:[-=] +
        *if* _Self.stop_ *then* +
            _Self.mode_:= _undefined_ +
                *do forall* _t: t_ stem:[in] [smallcap]#_Token_# stem:[^^]     _t.owner_ = _Self_ +
                    _t.owner_:= _undefined_ +
                *enddo* +
        *endif* +
*endwhere*
====

[[predefined_names_and_special_symbols]]
==== Predefined names and special symbols

To define an ASM model, in particular the ASM model capturing the semantics of SDL-2010, certain names and their intended interpretation are predefined. These names are grouped and listed in this clause (where stem:[D] refers to the syntactic category of domains). For prefix, infix and postfix operators, an underline ("_") is used to indicate the position of their arguments. Moreover, the precedence of the operators is indicated by prec(n), where n is a number. Higher numbers mean tighter binding. Monadic operators have a tighter binding than binary ones. Binary operators are associative to the left.

[[asm_specific_domains]]
===== ASM-specific domains

[%unnumbered]
|===
<.<| *static domain* stem:[X] <.<| ASM base set (meta domain)
<.<| *static domain* [smallcap]#_Boolean_# <.<| Boolean values
<.<| *static domain* [smallcap]#_Nat_# <.<| Natural values greater than or equal to zero
<.<| *static domain* [smallcap]#_Real_# <.<| Real values
<.<| *shared domain* [smallcap]#_Agent_# <.<| ASM agents
<.<| *static domain* [smallcap]#_Program_# <.<| ASM programs
<.<| *static domain* [smallcap]#_Token_# <.<| Syntax tokens (character strings)
<.<| *_ ** <.<| Domain constructor: finite sequences of
<.<| *_ +* <.<| Domain constructor: non-empty, finite sequences of
<.<| *_ -set* <.<| Domain constructor: finite sets of
<.<| *_* &times; _   prec(7) <.<| Tuple domain constructor
<.<| *_* stem:[uu] _   prec(6) <.<| Union domain constructor
|===

[[asm_specific_functions]]
===== ASM-specific functions

[%unnumbered]
|===
<.<| *static* _undefined_: stem:[rarr X] <.<| Indicator for undefined values
<.<| *monitored* _Self_: stem:[rarr] [smallcap]#_Agent_# <.<| Self reference for ASM agents
<.<| *controlled* _program_: [smallcap]#_Agent_# stem:[rarr] [smallcap]#_Program_# <.<| Program of an ASM agent
<.<| *monitored* _currentTime_: stem:[rarr] [smallcap]#_Real_# <.<| The current system time
|===

[[boolean_functions_and_predicates]]
===== Boolean functions and predicates

[%unnumbered]
|===
<.<| *static* _true_: stem:[rarr] [smallcap]#_Boolean_# <.<| Predefined literal
<.<| *static* _false_: stem:[rarr] [smallcap]#_Boolean_# <.<| Predefined literal
<.<| _ = _   prec(4) <.<| Equality
<.<| _ stem:[!=] _   prec(4) <.<| Inequality
<.<| _ stem:[^^] _   prec(3) <.<| Logical and
<.<| _ stem:[vv] _   prec(2) <.<| Logical or
<.<| _ stem:[rarr] _   prec(1) <.<| Implication
<.<| _ stem:[hArr] _   prec(1) <.<| Logical equivalence
<.<| stem:[not] _ <.<| Negation
<.<| stem:[EE x in D: P(x)]   prec(0) <.<| Existential quantification (at least one element)
<.<| stem:[EE !x in D: P(x)]   prec(0) <.<| Unique existential quantification (exactly one element)
<.<| stem:[AA x in D: P(x)]   prec(0) <.<| Universal quantification
|===

[[terms]]
===== Terms

[%unnumbered]
|===
<.<| _X_ <.<| 0-ary function application
<.<| _f(t~1~,..., t~n~)_ <.<| Function application with n argument expressions
<.<| *if* _Formula_ *then* _Term_ *else* _Term_ *endif* <.<| Conditional expression; again we use *elseif* instead of *else* *if*
<.<| *s-* _ (_) <.<| Tuple selection function (see Tuples below)
<.<| *mk-* _ (...) <.<| Tuple construction (see Tuples below)
<.<a| *inv-* _ (...) <.<| The inverse of a function or map, +
*inv-* _Fun(x) =~def~ take({ a stem:[in] D:Fun(a) = x })_
|===

[[functions_and_relations_on_syntax_tokens_character_strings]]
===== Functions and relations on syntax tokens (character strings)

[%unnumbered]
|===
<.<| _ stem:[+] _   prec(6) <.<| String concatenation
<.<| " _ " <.<| Domain constructor – QUOTATION MARKS around character string
<.<| _chr_: [smallcap]#_Nat_# stem:[rarr] [smallcap]#_Token_# <.<| Single character _Token_ for character with value given by [smallcap]#_Nat_#
<.<| _head_: [smallcap]#_Token_# stem:[rarr] [smallcap]#_Token_# <.<| First character of string representing the [smallcap]#_Token_#
<.<| _last_: [smallcap]#_Token_# stem:[rarr] [smallcap]#_Token_# <.<| Last character of string representing the [smallcap]#_Token_#
<.<| _length_: [smallcap]#_Token_# stem:[rarr] [smallcap]#_Nat_# <.<| Length of the string representing the [smallcap]#_Token_#
<.<| _num_: [smallcap]#_Token_# stem:[rarr] [smallcap]#_Nat_# <.<| [smallcap]#_Nat_# value of first character of string representing the [smallcap]#_Token_#
<.<| _substring_: [smallcap]#_Token_# &times; [smallcap]#_Nat_# &times; [smallcap]#_Nat_# stem:[rarr] [smallcap]#_Token_# <.<| substring of string representing the [smallcap]#_Token_# from element i length j.
<.<| _tail_: [smallcap]#_Token_# stem:[rarr] [smallcap]#_Token_# <.<| Tail of string representing the [smallcap]#_Token_#.
|===

[[functions_and_relations_on_integers]]
===== Functions and relations on integers

[%unnumbered]
|===
<.<| _ > _, _ ≥ _, _ < _ , _ ≤ _   prec(4) <.<| Comparison operators
<.<| _ + _   prec(6) <.<| Addition
<.<| _ - _   prec(6) <.<| Subtraction
<.<| _ * _   prec(7) <.<| Multiplication
<.<| _ / _   prec(7) <.<| Division
<.<| _ ^ _   prec(8) <.<| Raise x to the power y
<.<| _0, 1, ..._ <.<| Integer literals
|===

[[functions_on_sequences]]
===== Functions on sequences

[%unnumbered]
|===
<.<| *static* _empty_: stem:[rarr D^(**)] <.<| Empty sequence
<.<| *static* _head_: stem:[D^(**) rarr D] <.<| Head of the sequence (_undefined_ when empty)
<.<| *static* _tail_: stem:[D^(**) rarr D^**] <.<| Tail of the sequence (_undefined_ when empty)
<.<| *static* _last_: stem:[D^(**) rarr D] <.<| Last element of a sequence (_undefined_ when empty)
<.<| *static* _length_: stem:[D^(**) rarr] [smallcap]#_Nat_# <.<| Length of a sequence
<.<| *static* < >: stem:[D_1 xx D_2 xx ... xx D_n rarr (D_1 uu D_2 uu ... uu D_n)^{**}] <.<| Sequence constructor; arguments are listed inside the brackets, separated by commas
<.<| _1 ... n_ <.<| Sequence constructor for the sequence stem:[< 1,2,..n >]; can be used so long as it is clear that this constructs a sequence and not a set.
<.<| _ ⁀ _ prec(6) <.<| Concatenation of sequences
<.<| _toSet_: stem:[D^{**} rarr D] *-set* <.<| Conversion of the elements of a sequence into a set
<.<| _ [_] <.<| Access an element of a list; the index within the brackets must be of type [smallcap]#Nat#
<.<| _ *in* _   prec(4) <.<| Element of?
<.<| _<expression> \| <var>_ *in* _<seq>: <cond> >_ <.<| Sequence comprehension; acts like a filter on _<seq>_, i.e., order-preserving; _<seq>_ is an input sequence whose values are bound to _<var>_; _<var>_ is a free variable in _<expression>_; evaluating _<expression>_ with _<var>_ bound to a value of _<seq>_ yields a value; _<cond>_ is a condition which determines whether or not that value will be included in the final sequence.
<.<| _< <var>_ *in* _<seq>_: _<cond> >_ =~def~  _< <var>_ \| _<var>_ *in*  _<seq>_: _<cond> >_ <.<| Abbreviated sequence comprehension; _<cond>_ acts as a filter on  _<seq>_
<.<| _< <expression>_ \| _<var>_ *in* _<seq> >_ =~def~ _< <expression>_ \| _<var>_ *in* _<seq>_: _true >_ <.<| Abbreviated sequence comprehension
|===

NOTE: The character ⁀ is the Unicode character with the decimal value 8256 (use find u^8256 in MSWord to locate).

[[functions_on_sets]]
===== Functions on sets

[%unnumbered]
|===
<.<| _ stem:[uu] _   prec(6) <.<| Set union
<.<| _ stem:[nn] _   prec(7) <.<| Intersection
<.<| _ \ _   prec(6) <.<| Set subtraction
<.<| _ stem:[in] _   prec(4) <.<| Element of?
<.<| _ stem:[!in] _   prec(4) <.<| Not element of?
<.<| _ stem:[sube] _   prec(4) <.<| Subset of?
<.<| _ stem:[sub] _   prec(4) <.<| Proper subset of?
<.<| \| _  \| <.<| Cardinality of a set
<.<| stem:[uuu] _ <.<| Big union: union of all sets included within the argument set
<.<| stem:[O/] <.<| Empty set
<.<| *static* { }: stem:[D_1 xx D_2 xx ... xx D_n rarr (D_1 uu D_2 uu ... uu D_n)] *-set* <.<| Set constructor; comma-separated list of arguments in the brackets
<.<| _1..n_ <.<| Set constructor for the set stem:[{1,2,..n}]; can be used where there is no ambiguity with sequence constructor.
<.<| _take_: stem:[D bb "-set" rarr D] <.<| Select an arbitrary element from the set, or _undefined_ for an empty set
<.<| _ stem:[..] _   prec(5) <.<| Natural range from the first value to the second. Empty set when the second expression is smaller than the first one
<.<| { _<expression>_ \| _<var>_ stem:[in] _<set>_: _<cond>_} <.<| Set comprehension, acts like a filter on _<set>_; _<set>_ is an input set; _<expression>_ is evaluated for each binding of _<var>_ to a value of _<set>_, yielding a candidate for inclusion in the new set; _<cond>_ determines whether or not the candidate is included in the final set.
<.<| {_<var>_ stem:[in] _<set>: <cond>_ } =~def~ _{<var> \| var_ stem:[in] _<set>_: _<cond>_ } <.<| Abbreviated set comprehension
<.<| { _<expression> \| <var>_ stem:[in] _<set>_ } =~def~ { _<expression> \| <var>_ stem:[in] _<set>_: _true_ } <.<| Abbreviated set comprehension
|===

[[patterns_and_case_expressions]]
===== Patterns and case-expressions

Patterns provide a means to easily access the structure of values. The following patterns are provided:

* Variables: A variable matches any value. However, if the variable is already bound, it only matches itself.

* Anonymous variables: Anonymous variables are denoted by "*". They are shorthand for introducing an unused variable.

* Constructor: A constructor is given by its name and the arguments that are again patterns. It matches any value that is constructed using that constructor and with the arguments matching their corresponding pattern.

Named pattern: The notation Variable = Pattern introduces a name for (the value matching) the pattern.

Patterns are used to describe functions on the syntax tree. The non-terminal names of the grammar are used as the constructor functions.

A case expression is used to determine a value depending on pattern matching.

[pseudocode]
[%unnumbered]
====
_CaseExpression_ ::= *case* _Term_ *of* +
                               | _Pattern~1~_ *then* _Term~1~_ +
                               | _Pattern~2~_ *then* _Term~2~_ +
                               _..._ +
                               [ *otherwise* _Term~0~_ ] +
                     *endcase*
====

If the value of _Term_ matches at least one _Pattern~i~_, then the result of the case expression is given by the _Term~i~_. If no pattern matches, the result is _Term~0~_ (if present). Otherwise, the result is _undefined_.

[[union_domains]]
===== Union domains

Union domains contain the values of their constituent domains. They are used below as models for named and unnamed unions and alternative right sides to abstract syntax rules.

[pseudocode]
[%unnumbered]
====
_D =~def~ D~1~ stem:[uu] D~2~_
====

[[sequence_domains]]
===== Sequence domains

Sequence domains contain sequences of the values of their constituent domains. They are used below as models for named and unnamed sequences, and sequences defined as (parts of) the right sides of abstract syntax rules expressed using extended BNF.

[pseudocode]
[%unnumbered]
====
_D =~def~ D~1~^***^_
====

[[tuples]]
===== Tuples

Tuple domains contain elements of the Cartesian product of their constituent domains. They are used below as models for the tuples specified by the right sides of abstract syntax rules. For every declared tuple domain, several implied constructor and selector functions are defined. For example, the tuple definition:

[pseudocode]
[%unnumbered]
====
_D =~def~ D~1~ stem:[xx] D~2~^*\**^ stem:[xx] D~3~ *-set* stem:[xx] D~1~ stem:[xx] (D~1~ stem:[uu] D~2~) stem:[xx] (D~1~ stem:[xx] D~2~)^***^ stem:[xx] (D~1~ stem:[xx] D~2~) *-set* stem:[xx] (D~1~ stem:[uu] D~2~)_ *-set*
====

also defines the following constructor and selector functions:

[pseudocode]
[%unnumbered]
====
*mk-* _D: D~1~ stem:[xx] D~2~^*\**^ stem:[xx] D~3~ *-set* stem:[xx] D~1~ stem:[xx] (D~1~ stem:[uu] D~2~) stem:[rarr] D_ +
*s-* _D~1~: D stem:[rarr] D~1~_ +
*s-* _D~2~ *-seq*: D stem:[rarr] D~2~^***^_ +
*s-* _D~3~_ *-set*: _D stem:[rarr] D~3~_ *-set* +
*s2-* _D~1~: D stem:[rarr] D~1~_ +
*s-implicit*: _D stem:[rarr] D~1~_ stem:[uu] _D~2~_ +
*s-implicit-seq*: _D stem:[rarr] (D~1~ stem:[xx] D~2~)^***^_ +
*s-implicit-set*: _D stem:[rarr] (D~1~ stem:[xx] D~2~)_ *-set*
====

When the tuple includes the same domain more than once, selector functions similar to *s2*- stem:[D_1] are defined. For union, the special selector function s-**implicit** is defined.

If a domain on the right hand side is optional (written as [_D_]), the selector function **s**-stem:[D] is still valid and gives the result _undefined_ if stem:[D] is absent and the value of selecting stem:[D] otherwise. Similarly **s**-_D_-**seq** is valid for [stem:[D^**]], and **s-**_D_-**set** is valid for [_D_-**set**].

An invalid selector returns _undefined_.

[[abstract_syntax_rules]]
===== Abstract syntax rules

Abstract syntax rules from the language definition are directly translated to the ASM notation, using the metalanguage for the concrete grammar as defined in [ITU-T Z.111] with the modified representation of semantic subcategories used in Annex F2. This allows rules to be expressed using the usual BNF conventions extended to include square brackets to indicate optional items, suffixes to indicate various kinds of list, and curly brackets to group related items.

An abstract syntax rule defined with "::" declares a domain of syntax nodes. Each syntax node has an identity and a value. The value is a member of an auxiliary domain of tuples of syntax nodes. For example, the rule

[pseudocode]
[%unnumbered]
====
_Symbol_ stem:[::] _Symbol~1~ Symbol~2~_
====

declares

[pseudocode]
[%unnumbered]
====
*controlled domain* _Symbol_
_Symbol-aux =~def~ Symbol~1~ stem:[xx] Symbol~2~_
*controlled* _contents-Symbol: Symbol stem:[rarr] Symbol-aux_
====

The abbreviation **mk-**_Symbol_ creates new elements of the domain _Symbol_,

[pseudocode]
[%unnumbered]
====
**mk-**_Symbol (s1: Symbol~1~, s2: Symbol~2~)_ stem:[-=] +
*extend* _Symbol_ *with* _v_ +
    _contents-Symbol(v) := (s1, s2)_ +
*endextend*
====

Note that **mk-**_Symbol_ is not an ASM function, but an abbreviation for an ASM rule.

Selector functions, s-, select the components of the tuple that is the value of a syntax node.

[pseudocode]
[%unnumbered]
====
**s-**_Symbol~1~: Symbol stem:[rarr] Symbol~1~_ +
**s-**_Symbol~2~: Symbol stem:[rarr] Symbol~2~_ +
**s-**_Symbol~1~(x: Symbol): Symbol~1~_           =~def~ **s-**_Symbol~1~ (x.contents-Symbol)_ +
**s-**_Symbol~2~(x: Symbol): Symbol~2~_           =~def~ **s-**_Symbol~2~ (x.contents-Symbol)_
====

Here is a more elaborate example, illustrating the definitions introduced by a variety of extended BNF constructs.

[pseudocode]
[%unnumbered]
====
_Symbol_ stem:[::] _Symbol~1~ Symbol~2~^+^  Symbol~3~_ **-set**_[Symbol~4~]_ +
{ _Symbol~1~ | Symbol~2~ } {Symbol~1~ Symbol~2~}^***^ { Symbol~1~ | Symbol~2~ }_ *-set*
====

which is translated to:

[pseudocode]
[%unnumbered]
====
_Symbol-aux =~def~ Symbol~1~ stem:[xx] Symbol~2~^*\**^ stem:[xx] Symbol~3~_ *-set* stem:[xx] _Symbol~4~ stem:[xx] ( Symbol~1~ stem:[uu] Symbol~2~) stem:[xx] ( Symbol~1~ stem:[xx] Symbol~2~)^***^ stem:[xx] ( Symbol~1~ stem:[uu] Symbol~2~)_ *-set* +
*controlled domain* _Symbol_ +
*controlled* _contents-Symbol_: _Symbol stem:[rarr] Symbol-aux_ +
*s-* _Symbol~1~ (x: Symbol): Symbol~1~_ =~def~ *s-* _Symbol~1~ ( x.contents-Symbol)_ +
*s-* _Symbol~2~_ *-seq* _( x: Symbol): Symbol~2~^*\**^_ =~def~ *s-* _Symbol~2~_ *-seq* _(x.contents-Symbol)_ +
*s-* _Symbol~3~_ *-set* _( x: Symbol): Symbol~3~_ *-set* =~def~ *s-* _Symbol~3~_ *-set* _(x.contents-Symbol)_ +
*s-* _Symbol~4~ ( x: Symbol): Symbol~4~_ =~def~ *s-* _Symbol~4~ (x.contents-Symbol)_ +
*s-implicit* _( x: Symbol): (Symbol~1~ stem:[uu] Symbol~2~)_ =~def~ *s-implicit* _( x.contents-Symbol)_ +
*s-implicit-seq* _( x: Symbol): ( Symbol~1~ stem:[xx] Symbol~2~)^***^_ =~def~ *s-implicit-seq* _(x.contents-Symbol)_ +
*s-implicit-set* _(x: Symbol): ( Symbol~1~ stem:[uu] Symbol~2~ )_ *-set* =~def~ *s-implicit-set* _( x.contents-Symbol)_
====

As with the previous example, an abbreviation **mk**-_Symbol_ is also introduced. This abbreviation creates a new object of domain _Symbol_ using the *extend* primitive and sets the _contents-Symbol_ value of the newly produced object to the corresponding element of _Symbol-aux_.

[pseudocode]
[%unnumbered]
====
*mk-* _Symbol(s1: Symbol~1~, s2seq: Symbol~2~^*\**^, s3set: Symbol~3~_ *-set*, _s4: Symbol~4~, s: (Symbol~1~ stem:[uu] Symbol~2~),_ +
                 _s1s2seq: (Symbol~1~ stem:[xx] Symbol~2~)^***^, sset: (Symbol~1~ stem:[uu] Symbol~2~)_ *-set*) stem:[-=] +
      *extend* _Symbol_ *with* _v_ +
         _contents-Symbol(v) := (s1, s2seq, s3set, s4, s, s1s2seq, sset)_ +
      *endextend*
====

The abbreviation **mk**-_Symbol_ is not a function, but in fact an ASM rule item. Therefore, it must be used only within ASM rules and not as an ASM location.

If for a given _Symbol_, _sym_, the optional stem:[Symbol_4] is not present, that fact is expressed in the ASM model by leaving the corresponding value _undefined_: _sym.s-Symbol~4~_ = _undefined_. An empty sequence of symbols (constructor with no parts) is denoted by (). For example, the abstract syntax rule

[pseudocode]
[%unnumbered]
====
_Symbol_ stem:[::] ()
====

declares a singleton domain, _Symbol_, whose only element is the empty tuple.

The equality for syntax nodes is always a structural equality, i.e., the contents of the symbols are compared instead of the symbols themselves.

A rule of the form

[pseudocode]
[%unnumbered]
====
_Symbol_ stem:[::] _Symbol~1~ | Symbol~2~ | ... | Symbol~n~_ (stem:[n >= 1])
====

where each alternative right side consists of a single symbol, is equivalent to

[pseudocode]
[%unnumbered]
====
_Symbol_ stem:[::] _{Symbol~1~ | Symbol~2~ | ... | Symbol~n~}_ (stem:[n >= 1])
====

In this case, there are selectors *.s-* _Symbol~i~_ , stem:[(i = 1, ..., n)] and if stem:[x in] _Symbol_, then all but one of those selectors will have the value _undefined_. Moreover, _x._ *s-implicit* _= x.contents-Symbol_.

More usually, rules like this will be represented as named unions. The syntax rules introducing named unions have the form:

[pseudocode]
[%unnumbered]
====
_Symbol = Symbol~1~ | Symbol~2~ | ... | Symbol~n~_ (stem:[n >= 1])
====

which is modelled as:

[pseudocode]
[%unnumbered]
====
_Symbol =~def~ Symbol~1~ stem:[uu] Symbol~2~ stem:[uu] ... stem:[uu] Symbol~n~_
====

Note that since _Symbol_ is a _union_ domain, the expansion yields a domain definition, but no abbreviation **mk**-_Symbol_ and no selector functions *s-* _Symbol~i~_ (stem:[i = 1,... , n]) that can be applied to elements of _Symbol_.

Of course, it is still possible to construct elements of _Symbol_ using any constructor that generates an element any of the domains _Symbol~1~, Symbol~2~, ..., Symbol~n~_, and given stem:[x in] _Symbol_, an expression of the form _x_ stem:[in] _Symbol~i~_ (stem:[i = 1, ... , n]) will to test whether or not _x_ belongs to one of the constituent domains of _Symbol_.

If a name is not required, unnamed unions may be introduced by rules like:

[pseudocode]
[%unnumbered]
====
_Symbol_ stem:[::] _Symbol~1~ { Symbol~21~ | ... | Symbol~2N~ }_
====

instead of introducing a name for the union:

[pseudocode]
[%unnumbered]
====
_Symbol_ stem:[::] _Symbol~1~ Symbol~2~_
_Symbol~2~ = Symbol~21~ | ... | Symbol~2N~_
====

Named sequences can be introduced using rules like this:

[pseudocode]
[%unnumbered]
====
_Symbol = Symbol~1~^***^_
====

which defines the domain of sequences of elements of _Symbol~1~_. Similarly, a rule like

[pseudocode]
[%unnumbered]
====
_Symbol = { Symbol~1~ Symbol~2~}^***^_
====

defines the domain of sequences of tuples _(a,b)_ where _a_ stem:[in] _Symbol~1~_ and _b_ stem:[in] _Symbol~2~_

As with named unions, _Symbol_ yields a domain definition, but not functions *mk*- nor *s*-. Elements of _Symbol_ are constructed using the sequence constructor, stem:[< >], and components of _Symbol_ can be accessed using the functions on sequences.

It is not always necessary to name a sequence explicitly. Unnamed sequences may be introduced by rules like:

[pseudocode]
[%unnumbered]
====
_Symbol_ stem:[::] _Symbol~1~ { Symbol~21~ ... Symbol~2N~ }^***^_
====

or like:

[pseudocode]
[%unnumbered]
====
_Symbol_ stem:[::] _Symbol~1~ { Symbol~21~ | ... | Symbol~2N~}^***^_
====

Named and unnamed sets can be introduced in a similar way.

For each SDL-2010 keyword *KEYWORD*, there is an associated keyword domain _Keyword_ with just one value:

[pseudocode]
[%unnumbered]
====
*static domain* _Keyword_
====

It is required that all keyword domains are mutually disjoint.

Given the abstract grammar, there is a derived domain called _DefinitionAS1_, which is composed of all abstract syntax symbol domains as follows:

[pseudocode]
[%unnumbered]
====
_DefinitionAS1 =~def~ Symbol~1~ stem:[uu] Symbol~2~ stem:[uu] ... stem:[uu] Symbol~n~_
====

where _Symbol~1~, Symbol~2~, ..., Symbol~n~_  are _all_ the symbols (terminal and non-terminal) of the abstract grammar. This includes unnamed non-terminals that appear in the syntax such as _Graph-node^*\**^_ and _{Terminator | Decision-node}_ in the AS1 rule _Transition_, and _{Open-range | Closed-range}^***^_ in the AS1 rule _Size-constraint_, which in ASM are denoted (respectively) as _Graph-node_ *-seq*, _(Terminator stem:[uu] Decision-node)_ and _(Open-range stem:[uu] Closed-range)_ *-seq*.

There is a similar domain _DefinitionAS0_ for the concrete grammar (AS0).

[[abstract_syntax_tree]]
===== Abstract syntax tree

The syntax nodes declared by abstract syntax rules can be used to construct an abstract syntax tree.

To navigate downward in a given abstract syntax tree, the functions *s-* can be used. To navigate upward, two parent functions are defined.

[pseudocode]
[%unnumbered]
====
*controlled* _parentAS1: DefinitionAS1_ stem:[rarr] _DefinitionAS1_ +
*controlled* _parentAS0: DefinitionAS0_ stem:[rarr] _DefinitionAS0_
====

Suppose _node_ is an abstract syntax node and a member of the domain _Symbol_, one of the constituent domains of _DefinitionAS1_:

[pseudocode]
[%unnumbered]
====
_node_ stem:[in] _Symbol_ stem:[sub] _DefinitionAS1_
====

The parent of _node_, if it exists, includes _node_, in its _contents-Symbol_. That is,

[pseudocode]
[%unnumbered]
====
_parentAS1 (node: DefinitionAS1): DefinitionAS1_ =~def~ +
    *if* _node = undefined_ *then* _undefined_ +
    *elseif* _node = rootNodeAS1_ *then* _undefined_ +
    *else* _take_ ({ _p_ stem:[in] _Symbol_ stem:[sub] _DefinitionAS1: node_ *in*  _p.contents-Symbol_ }) +
    *endif*
====


Similarly, for _node_ stem:[in] _Symbol_ stem:[sub] _DefinitionAS0_:

[pseudocode]
[%unnumbered]
====
_parentAS0 (node: DefinitionAS0): DefinitionAS0_ =~def~ +
    *if* _node = undefined_ *then* _undefined_ +
    *elseif* _node = rootNodeAS0_ *then* _undefined_ +
    *else* _take ({ p_ stem:[in] _Symbol_ stem:[sub] _DefinitionAS0_: _node_ *in* _p.contents-Symbol_ }) +
    *endif*
====

Moreover, two functions are defined to find the parent of a particular kind.

[pseudocode]
[%unnumbered]
====
_parentAS0ofKind (from: DefinitionAS0, x: DefinitionAS0_ *-set*): _DefinitionAS0_ =~def~ +
    *if* _from = undefined_ *then* _undefined_ +
    *elseif* _from_ stem:[in] _x_ *then* _from_ +
    *else*  _parentAS0ofKind (from.parentAS0, x_) +
    *endif*


_parentAS1ofKind (from: DefinitionAS1, x: DefinitionAS1_ *-set*): _DefinitionAS1_ =~def~ +
    *if* _from = undefined_ *then* _undefined_ +
    *elseif* _from_ stem:[in] _x_ *then* _from_ +
    *else* _parentAS1ofKind (from.parentAS1, x_) +
    *endif*
====

The top node of the current abstract or concrete syntax tree is denoted by the following 0-ary functions:

[pseudocode]
[%unnumbered]
====
*controlled* _rootNodeAS1: stem:[rarr] DefinitionAS1_ +
*controlled* _rootNodeAS0: stem:[rarr] DefinitionAS0_
====

The value of _rootNodeAS1.parentAS1_ is _undefined_.

The value of _rootNodeAS0.parentAS0_ is _undefined_.

The functions _isAncestorAS1_ and _isAncestorAS0_ determine if the first node is an ancestor of the second one:

[pseudocode]
[%unnumbered]
====
_isAncestorAS1 (n1: DefinitionAS1, n2: DefinitionAS1): [smallcap]#Boolean#_ =~def~
    _n1 = n2.parentAS1_ stem:[vv] _( n2 stem:[!=] rootNodeAS1 stem:[^^] isAncestorAS1 (n1 , n2.parentAS1))_


_isAncestorAS0 (n1: DefinitionAS0, n2: DefinitionAS0): [smallcap]#Boolean#_ =~def~
    _n1 = n2.parentAS0 stem:[vv] ( n2 stem:[!=] rootNodeAS0 stem:[^^] isAncestorAS0 ( n1, n2.parentAS0))_
====

The functions _isSameNodeAS1_ and _isSameNodeAS0_ determine if the first node is the same node as the second one, that is they are equal and in the same position in the syntax tree:

[pseudocode]
[%unnumbered]
====
_isSameNode1 (n1: DefinitionAS1, n2: DefinitionAS1): [smallcap]#Boolean#_ =~def~ +
    _n1 = n2 stem:[^^] (n1 = rootNodeAS1 stem:[vv] isSameNode1 (n1.parentAS1, n2.parentAS1))_

_isSameNode0 (n1: DefinitionAS0, n2: DefinitionAS0): [smallcap]#Boolean#_ =~def~ +
    _n1 = n2 stem:[^^] (n1 = rootNodeAS0 stem:[vv] isSameNode0 (n1.parentAS0, n2.parentAS0))_
====

The abstract syntax tree AS0 can be modified using the following derived functions:

[pseudocode]
[%unnumbered]
====
_replaceInSyntaxTree0: DefinitionAS0 stem:[xx] DefinitionAS0 stem:[xx] DefinitionAS0 stem:[rarr] DefinitionAS0_
====

The first parameter of the function is the old sub-tree, the second one is the new sub-tree and the third parameter is the old tree. The function returns the new tree, where all old sub-trees are replaced by the new sub-tree.

[pseudocode]
[%unnumbered]
====
_replaceInSyntaxTree0: DefinitionAS0 stem:[xx] DefinitionAS0 stem:[xx] DefinitionAS0 stem:[rarr] DefinitionAS0_
====

The first parameter of the function is the old sub-tree, the second one is the new sub-tree and the third parameter is the old tree. The function returns the new tree, where the first old sub-tree is replaced by the new sub-tree, and each subsequent old sub-tree occurrence is unchanged.
